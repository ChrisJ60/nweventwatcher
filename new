#!/bin/zsh

#
# Network Event Watcher. Copyright (c) Chris Jenkins 2019, 2020
#
# Licensed under the Universal Permissive License v 1.0 as shown
# at http://oss.oracle.com/licenses/upl
#

############################################################
# reset all shell options to default
emulate -LR zsh
# set required options
setopt nullglob
setopt shwordsplit
setopt ksharrays

############################################################
# reset PATH to system default
eval "$(/usr/libexec/path_helper)"
hash -rf

############################################################
# Constants
readonly version="3.0.3"
readonly copyright="Copyright (c) Chris Jenkins 2019, 2020"

readonly ladir=~/Library/LaunchAgents
readonly dfltAgentName=com.jenkinsnet.netwatcher
readonly datadir=~/Library/Application\ Support/NwEventWatcher
readonly cfgdir=conf
readonly actdir=action
readonly tmpdir=tmp
readonly bindir=bin
readonly logdir=log
readonly logfile=nweventwatcher.txt
readonly envnames=envnames
readonly envdescs=envdescs
readonly warntimeout=warntimeout
readonly killtimeout=killtimeout
readonly acsqfile=acsq
readonly btsqfile=btsq
readonly numlogfile=numlog
readonly logcyclefile=logcycle
readonly lastlogcyclefile=lastlogcycle
readonly forcelogcyclefile=forcelogcycle
readonly pausefile=pause
readonly norescanfile=norescan
readonly actionlog=actionlog
readonly lanamef=laname
readonly cmdfile=cmd
readonly pidfile=pid
readonly swpidfile=swpid
readonly nwpidfile=nwpid
readonly reffile=refresh
readonly envfile=actenv
readonly sleepfile=sleep
readonly wakefile=wake
readonly batteryfile=battery
readonly acpowerfile=acpower
readonly nwchangefile=nwchange
readonly notifyfile=notify
readonly nwname=netwatcher
readonly actions=" a i b "
readonly subenv="#E#"
readonly subact="#A#"
readonly envWake="@awake"
readonly envWakeDesc="Used to set actions on system wake"
readonly envBattery="@battery"
readonly envBatteryDesc="System is on battery power"
readonly envDefault="@default"
readonly envDefaultDesc="Used to set default actions"
readonly envAll="@all"
readonly envAllDesc="The set of all environments, including ${envDefault} but excluding ${envWake}"
readonly unknownname="Unknown"
readonly unknowndesc="Unknown network environment"
readonly notifybundle="com.apple.NetworkUtility"

readonly integer secsPerDay=86400
readonly integer minsleepsecs=5
readonly integer mindarkwakesecs=10
readonly integer rintr=127
readonly integer minSettle=0
readonly integer maxSettle=300
readonly integer minInterval=5
readonly integer maxInterval=60
readonly integer minTimeout=0
readonly integer maxTimeout=180
readonly integer minWakeCheck=3
readonly integer maxWakeCheck=15
readonly integer minSleepQuantum=1
readonly integer maxSleepQuantum=5
readonly integer dfltAcSleepQuantum=1
readonly integer dfltBtSleepQuantum=3
readonly integer dfltWakeCheck=6
readonly integer dfltSettle=15
readonly integer dfltInterval=10
readonly integer dfltWarnTimeout=30
readonly integer dfltKillTimeout=60
readonly integer minNumLogs=1
readonly integer maxNumLogs=10
readonly integer dfltNumLogs=5
readonly integer minLogCycle=0
readonly integer maxLogCycle=365
readonly integer dfltLogCycle=7
readonly integer eventModeSleep=20
readonly integer minDarkWakeLag=30
readonly integer swSettleFactor=20
readonly integer minPause=15
readonly integer maxPause=86400
readonly integer foreverPause=999999999
readonly minPauseInt="00:00:15"
readonly maxPauseInt="24:00:00"

declare notifier=""
declare sleepwatcher=""
declare netwatcher=""
declare cmd
declare mypath
declare me
declare myuid
declare mytmp
declare mypid
declare mylog
declare actlog=""

integer enablePower=1
integer acSQ=${dfltAcSleepQuantum}
integer btSQ=${dfltBtSleepQuantum}
integer sleepQuantum=${dfltAcSleepQuantum}
integer useSW=0
integer SWpid=0
integer NWpid=0
integer wakeCheckValue=${dfltWakeCheck}
integer cmdkilltimeout=${dfltKillTimeout}
integer cmdwarntimeout=${dfltWarnTimeout}
integer maxlogs=${dfltNumLogs}
integer logcycle=${dfltLogCycle}
integer lastlogcycle=0
integer slpTS=0
integer dwslpTS=0
integer wakeTS=0
integer slpDur=0
integer prvDW=0
integer curDW=0
integer pendingDwTs=0
integer dwInterval=${eventModeSleep}+15
integer powerTS=0
integer inSleep=1
integer inDW=1
integer prvBattery=0
integer curBattery=1
integer eventTS=0
integer intr=1
integer refresh=1
integer rescan=1
integer ret=0
integer debug=1
integer forcepoll=1

#
# State tracking variables and arrays
#
integer nEnv=0
declare -a curEnv=( "" )
declare -a curA=( "" )
declare -a curI=( "" )
declare -a curAN=( 0 )
declare -a curIN=( 0 )
declare -a curAct=( 0 )
declare -a prvAct=( 0 )
declare dfltA
declare dfltI
integer dfltAN
integer dfltIN
declare wakeA
integer wakeAN
declare powerA
declare powerI
integer powerAN
integer powerIN

#
# avoid dependency on my 'isnumeric' binary
#

if ! command -v isnumeric >& /dev/null
then

isnumeric()
{
    local str
    local tmp

    if [[ $# -ne 1 ]]
    then
        return 2
    fi
    str="$1"
    if [[ ${#str} -eq 0 ]] || [[ ${#str} -gt 10 ]]
    then
        return 1
    fi
    tmp=$(echo "${str}" | tr -d 0123456789)
    if [[ "${tmp}" != "" ]]
    then
        return 1
    fi
    return 0
}

fi

help_usage()
{
    if [[ $# -gt 0 ]]
    then
    cat - <<EOF
USAGE
EOF
    else
    cat - <<EOF
Usage:
EOF
    fi
    cat - <<EOF

  ${me} help [usage | general | getnwenv | full | <cmd>]...
  ${me} version
  ${me} list {environments [-verbose] | actions [-script] | active}
  ${me} set <environment> {a | i | b} [-silent] <command> [<param>]...
  ${me} set <environment> {a | i | b} -notify
  ${me} clear <environment> {a | i | b} [-verbose]
  ${me} config [-clear | -script | [-warntimeout <w>] [-killtimeout <k>]
EOF
    if [[ ${enablePower} -eq 0 ]]
    then
    cat - <<EOF
              [-actionlog <path>] [-acsq <a>] [-btsq <b>]
EOF
    else
    cat - <<EOF
              [-actionlog <path>] [-acsq <a>]
EOF
    fi
    cat - <<EOF
              [-maxlogs <l>] [-logrotate <d>]]
  ${me} install [<agenturl>] [-settle <s>] [-interval <i>] [-notify]
  ${me} uninstall
  ${me} init

  ${me} refresh [-force]
  ${me} rescan
  ${me} status [-verbose] [-asleep]
  ${me} start
  ${me} stop
  ${me} pause [<interval>] [-norescan]
  ${me} resume [-rescan | -norescan]
  ${me} cleanup [-verbose]
  ${me} log [-action] [-follow | -clear | -fno <n>]
  ${me} log {-rotate | -info}

  ${me} monitor [-settle <s>] [-interval <i>] [-notify] [-fg]
EOF
    return 100
}

help_general()
{
    cat - <<EOF
NETWORK EVENT WATCHER

EOF
    if [[ ${enablePower} -eq 0 ]]
    then
    cat - <<EOF
Watch for, and react to, changes of network environment, system sleep/wake
events and power source change events.
EOF
    else
    cat - <<EOF
Watch for, and react to, changes of network environment and system sleep/wake
events.
EOF
    fi
    cat - <<EOF

This utility monitors the system for changes in the network environment, such
as:

-  Network interfaces appearing or disappearing
-  Network interfaces becoming active or inactive
-  Network interface IP addresses changing (IPv4 or IPv6)
-  VPN connections connecting or disconnecting

EOF
    if [[ ${enablePower} -eq 0 ]]
    then
    cat - <<EOF
It also monitors for system wake events (i.e. the system wakes from sleep)
and changes of power source (battery or AC).
EOF
    else
    cat - <<EOF
It also monitors for system wake events (i.e. the system wakes from sleep).
EOF
    fi
    cat - <<EOF

When one of the monitored events occurs, the utility can perform a user defined
action to react to the event.

DEPENDENCIES

This utility uses:

    1.   A 'getNwEnv' script which determines the currently active network
         environment(s) and defines the set of supported environments. This
         script must be provided by the user and must comply with the
         specification (see below).

    2.   The 'terminal-notifier' utility which is used to send notifications
         (https://github.com/julienXX/terminal-notifier). An easy way to
         install this is using HomeBrew (https://brew.sh):

             brew install terminal-notifier

         If 'terminal-notifier' is not installed then the notification
         feature will not work.

    3.   The 'sleepwatcher' utility which is used to detect system wake
         and power events (https://www.bernhard-baehr.de). An easy way to
         install this is using HomeBrew (https://brew.sh):

             brew install sleepwatcher

         You do NOT need to configure 'sleepwatcher' to run automatically.

         If 'sleepwatcher' is not installed then:

         - A less accurate, higher overhead mechanism will be used to detect
           system sleep/wake events and this may result in occasional missed
           events or false positives.

         - Detection of power source changes is not enabled so the '@battery'
           environment will not trigger any events.

INSTALLATION

1.  Make sure that your PATH setting includes both /usr/local/bin and
    /usr/local/sbin and that the system is set to include these in the
    default PATH (appropriate files in /etc/paths.d).

2.  Copy the main script to /usr/local/sbin (recommended) or /usr/local/bin.
    The script's default name is 'new' (Network Event Watcher) but you
    can give it any name you like as long as it does not conflict with any
    other executables on your system.

3.  Create (and test) your customised 'getNwEnv' script (see specification
    below) and put that in /usr/local/bin or /usr/local/sbin.

4.  Install the 'terminal-notifier' utility. If you do not install this
    utility then the notification feature will not work but everything
    else will still function correctly.

5.  Install the 'sleepwatcher' utility. If you do not install this
    utility then the '@awake' environment feature will still work but
    it will use a less reliable mechanism to detect system wakes which
    may occasionally result in missed events or false positives.

CONFIGURATION, STORAGE AND RESTRICTIONS

The utility stores its configuration and a few other small files in
'~/Library/Application Support/NwEventWatcher' hence all aspects of
configuration and operation are specific to an individual user.
Different users can have different configurations but only one
user's monitor/agent may be running at any one time.

CONCEPTS

Environment

    A specific network environment. The list of supported environments
    is that returned by executing 'getNwEnv list'. In addition to the
    environments determined by that command, the following special
    environments are also supported:

        Unknown  - Matches any environment not specifically recognised
                   by 'getNwEnv'.

        @default - Used to set default actions (see below).

        @awake   - Used to set an action for system wake events.

EOF
    if [[ ${enablePower} -eq 0 ]]
    then
    cat - <<EOF
        @battery - System is running on battery power.

        @all     - Matches all defined environments, including 'Unknown',
                   '@default', '@battery' and @awake.
EOF
    else
    cat - <<EOF
        @all     - Matches all defined environments, including 'Unknown',
                   '@default' and @awake.
EOF
    fi
    cat - <<EOF

Event

    An event occurs when a network environment transitions to active (from
    being inactive) or vice versa. The current set of active environments
    is determined by executing the command 'getNwEnv show -all'. Each
    individual environment (including 'Unknown') has its own A (became
    active) and I (became inactive) events. Since multiple environments
    may be active concurrently this means that in any checking cycle
    multiple events may be triggered.

    The non-network environment '@awake' corresponds to the system
    being awake. Only A events are supported for this environment;
    i.e. the system changed from being asleep to being awake.

EOF
    if [[ ${enablePower} -eq 0 ]]
    then
    cat - <<EOF
    The non-network environment '@battery' corresponds to the
    system running on battery power (as opposed to AC power).
    The A event for this environment occurs when the system switches
    from AC power to battery and the I event is the reverse of this.
EOF
    fi
    cat - <<EOF

Action

    A command associated with an event. When the event is triggered the
    associated action, if any, is executed.

EVENT DETECTION MECHANISM

The monitor task is responsible for detecting and reacting to events
based on the configuration. The monitor can be run directly, either as
a foreground activity, as a background task (preferred) or as a
LaunchAgent (even more preferred). Event detection uses an optimised
algorithm that combines polling with event notification to ensure
timely event detection with minimal system overhead.

Network change events are normally detected using an agent process that
hooks into the macOS System Configuration Framework. This agent gets
notified by macOS whenever any interesting network environment change
occurs and it in turn notifies the monitor task. This is an efficient
mechanism as it avoids the need to frequently poll for changes to the
network environment. If for some reason the SCF agent cannot function
then the monitor falls back to a polling based mechanism.

System wake and power events are normally detected using an agent
process that hooks into the macOS Power Notification mechanism.
This process is the 'sleepwatcher' utility which must be installed
separately.

Using 'sleepwatcher' is an efficient mechanism as it avoids the need to
frequently check to see if the system has woken from sleep. It is
also more reliable than the polling based mechanism. If 'sleepwatcher'
is not available, or cannot run, then the monitor falls back to the
less efficient and less accurate polling mechanism.

When operating in polling mode the monitor regularly checks for changes
to the network environment and for system wake events. The frequency
of these checks is determined by the '-interval' option (see below).
The default interval is ${dfltInterval} seconds and this should be adequate
for most situations.

RESPONSIVENESS VERSUS RESOURCE USAGE

Under typical usage conditions the monitor task and associated helper
tasks use very little CPU (roughly 0.5% of a single core on average).
There is a tuneable parameter, the sleep quantum, which can be varied to
reduce the (already low) resource usage at the cost of slightly reduced
responsiveness.

EOF
    if [[ ${enablePower} -eq 1 ]]
    then
    cat - <<EOF
The default sleep quantum is ${dfltAcSleepQuantum} second but this can be increased in 1
second increments, up to a maximum of ${maxSleepQuantum} seconds, by using the '-acsq'
parameter of the 'config' command.
EOF
    else
    cat - <<EOF
The monitor detects when the system transitions between AC power and battery
power and automatically adapts. When running on AC power it uses a sleep
quantum of ${dfltAcSleepQuantum} second for maximum responsiveness with low overhead, and when
running on battery power it increases the sleep quantum to ${dfltBtSleepQuantum} seconds which
significantly reduces CPU usage (and hence increases battery life) for
only a modest reduction in responsiveness. You can tune the values used
in both modes by using the '-acsq' and '-btsq' parameters of the 'config'
command. Values range between ${minSleepQuantum} and ${maxSleepQuantum}.
EOF
    fi
    cat - <<EOF

ACTION EXECUTION AND ORDERING

It is possible that multiple events may occur at the same time (or so close
together that they effectively occur at the same time). In such cases there
is a clearly defined order of execution for their associated actions.

-   Events are triggered for all environments that have transitioned
    from active to inactive (I), then events are triggered for all the
    environments that have transitioned from inactive to active (A).

EOF
    if [[ ${enablePower} -eq 0 ]]
    then
    cat - <<EOF
-   Events are triggered in the order in which the environment names
    are returned by the 'getNwEnv list' command. Events for the '@awake'
    environment are always triggered first, followed by events for the
    @battery environment and then events for recognised network
    environments. Events for the 'Unknown' environment are always
    triggered last.
EOF
    else
    cat - <<EOF
-   Events are triggered in the order in which the environment names
    are returned by the 'getNwEnv list' command. Events for the '@awake'
    environment are always triggered before events for recognised network
    environments and events for the 'Unknown' environment are always
    triggered last.
EOF
    fi
    cat - <<EOF

-   If there are no defined actions for an event then the event is ignored (it
    is stil logged); you do not need to define actions for every possible event.
    You can also create actions for the special environment named '@default'.
    These actions will then trigger for any event which does not have its own
    defined actions, except for the '@awake' event.

Actions execute synchronously to the monitor. While an action is executing
the monitor will not react to any new events, but in general new events which
occur during action execution will be queued and will be detected/processed
after the current set of actions have finished processing.

ACTION COMMAND EXECUTION ENVIRONMENT

Action commands are executed as background tasks. They should make no
assumptions about their environment other than as follows:

- PATH will be the system default PATH plus whatever may be defined
  in /etc/paths.d

- USER will be the username under which the monitor is running

- HOME will be the home directory of \$USER

Standard input is always redirected to /dev/null. If there is an action
log file defined then standard output and standard error will be redirected
to the log file otherwise they will be redirected to /dev/null. There is
no controlling terminal.

ACTION COMMANDS

When assigning commands to actions, or creating scripts to be used
as action commands, bear in mind the following:

-  Action commands run synchronously with the monitor task and so
   should not directly invoke long running operations. Ideally
   an action command should complete its processing within a few
   seconds. If you need to start a long running operation
   from an action command you should ensure that it is started
   as an asynchronous task (for example run it in the background)
   and the action command itself completes quickly.

-  Action commands can be passed two special parameters which they
   can inspect to determine the event that triggered the action.
   See the 'set' command below for details.

-  Action commands should avoid relying on any specific ordering of
   execution and dependencies on other action commands.

-  Generally A events are more useful than I events since they are
   more definitive. Nonetheless I events can sometimes be useful.
EOF
    return 100
}

help_getnwenv()
{
    cat - <<EOF
The GETNWENV SCRIPT

Overview

The user is responsible for providing a command (most likely a script) called
'getNwEnv' which must be installed in either /usr/local/bin or /usr/local/sbin.

This script is responsible for:

-  Defining the names and descriptions of the set of supported network
   environments.

-  Determining the set of currently active network environments.
   The definition of Active and Inactive is deliberately left to the user
   but typically Active means connected/usable and Inactive means the opposite.
   A good example is a VPN connection; when it is not connected it is Inactive
   and when it is connected it becomes Active. The same example holds true for
   WiFi and wired network connections.

Syntax and specification

The syntax for invoking the script is as follows. This is the minimum syntax;
the script may support additional functionality over and above what is specified
here.

getNwEnv list [-verbose]

    Display a list, one per line with no leading or trailing spaces, of all the
    network environments that are supported. An environment name may consist of
    alphanumeric characters and some special characters such as '-_@+-='. Spaces
    are not permitted within an environment name. The following environment
    names are reserved and should NOT be returned by this script; Unknown, @all,
    @awake and @default. Here is an example of what the output might look like:

    $ getNwEnv list
    Home-LAN
    Home-WiFi
    Work-LAN
    Work-WiFi
    Work-VPN

    The order in which the environments are displayed is significant to the
    network event watcher utility as it affects the order in which events are
    triggered.

    If the '-verbose' option is specified then each network name should be
    followed by a colon (:) and a textual description of the environment.
    For example:

    $ getNwEnv list -verbose
    Home-LAN:Wired connection to the home network
    Home-WiFi:WiFi connection to the home network
    Work-LAN:Wired connection to the office network
    Work-WiFi:WiFi connection to the office network
    Work-VPN:VPN connection to work

    The order in which the environments are displayed must be the same as
    when the '-verbose' option is not used.

getNwEnv show -all

    Display a list, one per line with no leading or trailing spaces, of the
    currently active network environments. For example if you are currently
    connected to your home WiFi but also using your VPN to access your work
    network then the output would look like this:

    $ getNwEnv show -all
    Work-VPN
    Home-WiFi

    The order in which the active environments are displayed is not significant.

Exit codes

The 'list' command should always return a zero exit code unless it is unable to
successfully generate the list, in which case the exit code should be > 0.

The 'show' command should return 0 if at least one of the supported environments
is active. If none of the supported environments is active it should not return
any textual output and the exit code should be 1. An exit code > 1 indicates
that an error occurred and the command was not able to determine the environment
status.
EOF
    return 100
}

help_cleanup()
{
    cat - <<EOF
cleanup

    Cleans up any residual helper processes. You should not normally need to
    use this option.

    Any running agent or monitor must be stopped before using this command.
EOF
    return 100
}

help_clear()
{
    cat - <<EOF
clear <environment> {a | i | b} [-verbose]

    Removes the specified action(s) for the named environment/event(s).

NOTE:
    If a monitor or agent is running, changes made with the 'clear' command will
    not take effect until a 'refresh' command has been issued.
EOF
    return 100
}

help_config()
{
    cat - <<EOF
config [-clear | -script | [-warntimeout <w>] [-killtimeout <k>]
        [-actionlog <path>] [-maxlogs <l>] [-logrotate <d>]
EOF
    if [[ ${enablePower} -eq 0 ]]
    then
    cat - <<EOF
        [-acsq <a>] [-btsq <b>]]
EOF
    else
    cat - <<EOF
        [-acsq <a>]]
EOF
    fi
    cat - <<EOF

    Displays/sets values for the command execution warning timer
    (-warntimeout), the command execution kill timer (-killtimeout),
    the action log file (-actionlog), the maximum number of retained
    log files (-maxlogs), the log file rotate interval in days
EOF
    if [[ ${enablePower} -eq 0 ]]
    then
    cat - <<EOF
    (-logrotate), the AC sleep quantum (-acsq) and the battery sleep
    quantum (-btsq) or clears all values previously set (-clear).
    Individual values can be cleared by specifying a value of '-'.
EOF
    else
    cat - <<EOF
    (-logrotate), the AC sleep quantum (-acsq) or clears all values
    previously set (-clear). Individual values can be cleared by
    specifying a value of '-'.
EOF
    fi
    cat - <<EOF
    Any value that does not have an explicitly defined value will use
    its default value (if any).

    If '-script' is specified, a set of commands are output that will
    re-create the current configuration.

    Timeout values must be between ${minTimeout} and ${maxTimeout}; a value of 0 for a timeout
    means 'no timeout'. Default values are ${dfltWarnTimeout} for warnings and ${dfltKillTimeout} for the
    kill timeout.

    If the warning timeout is > 0 and the execution of any action command
    takes longer than the timeout value then a warning message is logged.
    If the kill timeout is > 0 and the execution of any action command
    takes longer than the timeout value then the command task is killed and
    an error message is logged.

    If an action log file is defined then additional information about
    action execution will be logged there and the standard output and
    standard error of action commands will be redirected to the file.
    You can disable an existing action log by passing an empty string
    for the path (''); the log file is not deleted.

    Values for sleep quanta are specified in seconds and must be between
    ${minSleepQuantum} and ${maxSleepQuantum}.

    The 'maxlogs' value specifies the maximum number of log files to retain
    when using the log file rotation feature. The value must be between ${minNumLogs}
    and ${maxNumLogs}. The default is ${dfltNumLogs}.

    The 'logrotate' value specifies how often, in days, a running monitor
    should perform an automatic 'log -rotate' operation. The value must be
    between ${minLogCycle} and ${maxLogCycle}. The default is ${dfltLogCycle}. If this parameter is set to 0 then 
    automatic log rotation is not performed.

NOTE:
    If a monitor or agent is running, changes made with the 'config' command
    will not take effect until a 'refresh' command has been issued.
EOF
    return 100
}

help_init()
{
    cat - <<EOF
init

    Sets up the configuration from scratch; clears all defined timeouts and
    actions and regenerates the list of environments using 'getNwEnv list'.

    Any running monitor task or agent must be stopped before using this command.

    It is not usually necessary to use this command as an implicit 'init' is
    performed the very first time a user runs this utility.
EOF
    return 100
}

help_install()
{
    cat - <<EOF
install [<agenturl>] [-settle <s>] [-interval <i>] [-notify]

    Installs a user LaunchAgent so that the monitor runs as an agent whenever
    you are logged in. The agent must not be currently loaded in order to use
    this command. This is the preferred way to use this utility.

    The options are:

      agenturl
          The URL to use for the launch agent.
          The default is '${dfltAgentName}'.

      -settle s
          Wait for 's' seconds before starting to monitor for changes after
          starting or waking from sleep.
          ${minSettle} <= s <= ${maxSettle}. The default is ${dfltSettle}.

      -interval i
          Check for changes every 'i' seconds when using 'polling' mode.
          ${minInterval} <= i <= ${maxInterval}. The default is ${dfltInterval}.

      -notify
          Enables the macOS notification feature. Requires the
          'terminal-notifier' utility.
EOF
    return 100
}

help_list()
{
    cat - <<EOF
list {environments [-verbose] | actions [-script] | active}

    Displays a list of environment names, defined actions or the currently
    active environments (except '@awake'). For actions, if '-script' is
    specified the action list is output as a list of commands that will
    exactly re-create the existing setup.

    For actions, the 'list' command displays the current state of the on disk
    configuration which may not be the same as the in-memory copy currently
    being used by a running monitor/agent. See 'set', 'clear' and 'refresh'
    below.
EOF
    return 100
}

help_log()
{
    cat - <<EOF
log [-action] [-follow | -clear | -fno <n>]

    Display the current log file (or archived file <n> if '-fno' was
    specified) or clears all log files (-clear). Acts on the monitor log
    unless '-action' is specified when it acts on the action log, if configured.
    Using '-follow' displays new log entries as they are generated; interrupt
    the display using Ctrl-C.

log {-rotate | -info}

    Provides information about the current log files (-info) or rotates the
    log files (-rotate).

    Rotating the log renames the current log as <logname>.1 and so on up to a
    maximum of the configured value for 'maxlogs' set using the 'config' option.
    Logs exceeding 'maxlogs' are removed. This operation applies to both the
    monitor log and the action log, if configured. Manually rotating the logs
    also updates the timestamp used by the automatic rotation mechanism.

    The -rotate command signals the running monitor/agent which then rotates
    the log(s), hence this command can only be used when a monitor or agent
    is running.
EOF
    return 100
}

help_monitor()
{
    cat - <<EOF
monitor [-settle <s>] [-interval <i>] [-notify] [-fg]

    Runs the monitor directly; useful for special purposes.

    The options are:

      -settle s
          Wait for 's' seconds before starting to monitor for changes after
          starting or waking from sleep.
          ${minSettle} <= s <= ${maxSettle}. The default is ${dfltSettle}.

      -interval i
          Check for changes every 'i' seconds.
          ${minInterval} <= i <= ${maxInterval}. The default is ${dfltInterval}.

      -notify
          Enables the macOS notification feature. Requires the
          'terminal-notifier' utility.

      -fg
          Normally the monitor process is run as a separate background task.
          Specifying '-fg' causes it to be run in the foreground (in the
          invoking task).
EOF
    return 100
}

help_refresh()
{
    cat - <<EOF
refresh [-force]

    Tells a running monitor/agent to reload its configuration to pick up any
    pending changes. Normally the refresh is only performed if there are pending
    changes but you can force it to occur by specifying '-force'. Starting the
    monitor/agent using the 'start' or 'monitor' commands performs an implicit
    refresh.
EOF
    return 100
}

help_rescan()
{
    cat - <<EOF
rescan

    Tells a running monitor/agent to rescan the current set of active network
    environments and execute any defined A actions for all currently active
    environments. This is the same processing that occurs when a monitor or
    agent starts up.
EOF
    return 100
}

help_set()
{
    cat - <<EOF
set <environment> {a | i | b} [-silent] <command> [<param>]...

    Creates an action; sets a command to be executed when an event is triggered
    for the named environment. Events are:
        -  environment becomes active (a)
        -  environment becomes inactive (i)
        -  either (b)
    Note that 'b' is not a separate event; it is simply a shorthand way of
    creating an action for both 'a' and 'i' events. Only 'a' events may be
    defined for the '@awake' environment.

    'command' must be an executable file (binary, script, ...) and may be
    followed by optional parameters as required. The following special
    placeholders will be substituted for the corresponding values when the
    command is executed:

        #E# - The environment name for the event.
        #A# - The new environment state for the event; A = active, I = inactive.

    An absolute path must be used when specifying the command.

    If macOS notifications are enabled then a notification will be sent
    whenever an event with an associated action is triggered occurs unless
    '-silent' was specified when the action was created.

set <environment> {a | i | b} -notify

    Sets a 'notify only' action for an event. No command is executed but a
    notification is sent if macOS notifications are enabled.

NOTE:
    If a monitor or agent is running, changes made with the 'set' command will
    not take effect until a 'refresh' command has been issued.
EOF
    return 100
}

help_start()
{
    cat - <<EOF
start

    Starts the agent if it is configured and not already running.
EOF
    return 100
}

help_status()
{
    cat - <<EOF
status [-verbose] [-asleep]

    Displays the status of the monitor/agent. If '-verbose' is specified then
    status is also displayed for sleepwatcher, netwatcher and pending refresh.

    If '-asleep' is specified then sets the exit code as follows:

    0  -  An agent or monitor is running, sleepwatcher is running and the
          system is currently asleep (i.e. in a 'dark wake').

    1  -  An agent or monitor is running, sleepwatcher is running and the
          system is not currently asleep.

    >1 -  Any of the above conditions are not met, an error occurred etc.

   Normally using '-asleep' does not generate any output messages but you
   can get some informative messages by also specifying '-verbose'
EOF
    return 100
}

help_stop()
{
    cat - <<EOF
stop

    Stops the monitor/agent if it is running.
EOF
    return 100
}

help_pause()
{
    cat - <<EOF
pause [<interval>] [-norescan]

    Pauses the monitor/agent for the specified time interval or forever if
    no interval is specified. The interval may be specified as an integer
    (number of seconds) or in the format HH:MM:SS. If specified, the value
    must be between ${minPause} and ${maxPause} (${minPauseInt} and ${maxPauseInt}).

    While paused the monitor/agent will not detect, handle or log any events.

    The monitor/agent can be resumed early using the 'resume' command.
    Stopping the monitor/agent clears any existing pause state.

    Normally a rescan operation is performed when the monitor/agent
    resumes but this can be suppressed using '-norescan'.
EOF
    return 100
}

help_resume()
{
    cat - <<EOF
resume [-rescan | -norescan]

    Resumes a currently paused monitor/agent. Normally a rescan will be
    performed after the monitor/agent resumes but this can be suppressed
    by specifying '-norescan' or forced (if it was suppressed at pause
    time) by specifying '-rescan'.
EOF
    return 100
}

help_uninstall()
{
    cat - <<EOF
uninstall

    Uninstalls the user LaunchAgent so that the monitor no longer runs
    automatically. The agent must not be running in order to use this
    command.
EOF
    return 100
}

help_version()
{
    cat - <<EOF
version

    Displays version information.
EOF
    return 100
}

help_help()
{
    cat - <<EOF
help [usage | general | getnwenv | full | <cmd>]...

    Displays help information for the selected topics. If no topic is
    specified then displays this help. Topics are:

    usage     -  Usage and syntax.

    general   -  General information including overview, concepts, instalation,
                 dependencies etc.

    getnwenv  -  Detailed information on the 'getNwEnv' command that the
                 user must provide.

    full      -  Full help covering all topics.

    <cmd>     -  Detailed help for the specified command.
EOF
    return 100
}

help_full()
{
    help_general
    echo
    help_usage Y
    echo
    help_help
    echo
    help_version
    echo
    help_list
    echo
    help_set
    echo
    help_clear
    echo
    help_config
    echo
    help_install
    echo
    help_uninstall
    echo
    help_init
    echo
    help_refresh
    echo
    help_rescan
    echo
    help_status
    echo
    help_start
    echo
    help_stop
    echo
    help_pause
    echo
    help_resume
    echo
    help_cleanup
    echo
    help_log
    echo
    help_monitor
    echo
    help_getnwenv
    return 100
}

usage()
{
    local topic

    if [[ $# -eq 0 ]]
    then
        echo
        help_usage
        echo
    else
        echo
        for topic in "$@"
        do
            help_${topic}
            echo
        done
    fi
    exit 100
}

canonPath()
{
    cwd=$(pwd -P)
    nwd=$(dirname "$1")
    nfn=$(basename "$1")
    if ! cd "${nwd}" >&/dev/null
    then
        return 1
    fi
    nwd=$(pwd -P)
    if [[ -d "${nfn}" ]]
    then
        if ! cd "${nfn}" >&/dev/null
        then
            return 1
        fi
        nwd=$(pwd -P)
        echo "${nwd}"
    else
        echo "${nwd}/${nfn}"
    fi
    cd "${cwd}" >& /dev/null
    return 0
}

validPauseInterval()
{
    local pi
    local tmp
    local -a atmp
    local -i val=0
    local -i i=0

    if [[ $# -ne 1 ]] || [[ "$1" == "" ]]
    then
        return 2
    fi
    pi="$1"

    if isnumeric "${pi}"
    then
        if [[ ${#pi} -gt ${#maxPause} ]]
        then
            return 1
        fi
        val=${pi}
    else
        atmp=( ${(s/:/)pi} )
        if [[ ${#atmp[@]} -ne 3 ]]
        then
            return 1
        fi

        for i in 0 1 2
        do
            if ! isnumeric ${atmp[${i}]}
            then
                return 1
            fi
            if [[ ${i} -gt 0 ]] && [[ ${atmp[${i}]} -gt 59 ]]
            then
                return 1
            fi
            val=${val}*60+${atmp[${i}]}
        done
    fi

    if [[ ${val} -lt ${minPause} ]] || [[ ${val} -gt ${maxPause} ]]
    then
        return 1
    fi

    echo "${val}"
    return 0
}

checkHasBattery()
{
    if pmset -g cap | grep -q acwake
    then
        enablePower=0
    fi
    return 0
}

checkActionLog()
{
    if [[ "${actlog}" != "" ]]
    then
        if checkFileRW "${actlog}" Y
        then
            return 0
        else
            actlog=""
        fi
    fi
    return 1       
}

checkSleepwatcher()
{
    local sw
    local -i ret=1

    if [[ ${forcepoll} -eq 0 ]]
    then
        sleepwatcher=""
        useSW=1
        return ${ret}
    fi

    if sw=$(command -v sleepwatcher 2>/dev/null)
    then
        if ${sw} --version 2>/dev/null | grep -q 'Bernhard Baehr'
        then
            sleepwatcher="${sw}"
            useSW=0
            ret=0
        else
            sleepwatcher=""
            useSW=1
        fi
    fi

    return ${ret}
}

sendNotification()
{
    if [[ "${notifier}" == "" ]]
    then
        return 0
    fi
    ${notifier} -title "Network Event Watcher" -sender "${notifybundle}" -message "$1"
    return $?
}

cvtTS()
{
    if [[ $# -ne 1 ]]
    then
        echo "<invalid>"
        return 1
    fi
    if ! isNumeric "$1"
    then
        echo "<invalid>"
        return 1
    fi
    date -j -f '%s' "$1" '+%F %H:%M:%S'
    return 0
}

fmtInterval()
{
    local -i hh
    local -i mm
    local -i ss
    local -i v

    if [[ $# -ne 1 ]] || ! isnumeric "$1"
    then
        return 1
    fi
    v=$(( $1 ))

    ss=$(( v % 60 ))
    v=$(( v / 60))

    mm=$(( v % 60 ))
    v=$(( v / 60))

    hh=$(( v ))

    printf "%d:%2.2d:%2.2d" ${hh} ${mm} ${ss}

    return 0
}

logMsg()
{
    if [[ "${mylog}" != "" ]]
    then
        local ts
        ts=$(date '+%F %H:%M:%S')
        echo "${ts}" "$@" >> "${mylog}"
    fi
    return 0
}

debugMsg()
{
    if [[ ${debug} -eq 0 ]]
    then
        logMsg "$@"
    fi
    return 0
}

isNumeric()
{
    local tmp
    local n

    if [[ $# -ne 1 ]]
    then
        return 2
    fi
    tmp=$( echo "$1" | sed -e 's/^ *//' -e 's/ *$//')
    if [[ "${tmp}" == "" ]]
    then
        return 1
    fi
    tmp=$(echo "${tmp}" | tr -d '0-9')
    if [[ "${tmp}" != "" ]]
    then
        return 1
    fi

    return 0
}

isValidEnvironment()
{
    if [[ $# -ne 1 ]] || [[ "$1" == "" ]]
    then
        return 2
    fi
    grep -q "$1" "${datadir}/${cfgdir}/${envnames}"
    return $?
}

netwatcherRunning()
{
    local spid
    local rpid
    local -i npid

    if [[ ${forcepoll} -eq 0 ]]
    then
        return 3
    fi

    if [[ ${intr} -eq 0 ]]
    then
        return ${rintr}
    fi

    if checkFileR "${datadir}/${tmpdir}/${nwpidfile}"
    then
        spid=$(cat "${datadir}/${tmpdir}/${nwpidfile}")
        if [[ "${spid}" == "" ]]
        then
            rm -f "${datadir}/${tmpdir}/${nwpidfile}" >& /dev/null
            spid="0"
        fi
    fi

    rpid=$(pgrep -f -u "${myuid}" "${netwatcher}")
    if [[ "${rpid}" == "" ]]
    then
        rm -f "${datadir}/${tmpdir}/${nwpidfile}" >& /dev/null
        npid=0
    else
        npid=$(echo "${rpid}" | wc -l | awk '{ print $1 }')
    fi
    if [[ ${npid} -eq 0 ]]
    then
        rm -f "${datadir}/${tmpdir}/${nwpidfile}" >& /dev/null
        return 1
    elif [[ ${npid} -eq 1 ]]
    then
        if [[ "${spid}" != "${rpid}" ]]
        then
            echo "${rpid}" > "${datadir}/${tmpdir}/${nwpidfile}" 2> /dev/null
        fi
        echo "${rpid}"
        return 0
    fi

    return 2
}

waitforNetwatcherRunning()
{
    local -i n=0
    local nwpid

    while [[ ${n} -lt 30 ]]
    do
        if nwpid=$(netwatcherRunning)
        then
            echo "${nwpid}"
            return 0
        fi
        if [[ ${intr} -eq 0 ]]
        then
            return ${rintr}
        fi
        sleep 1
        n=${n}+1
    done

    return 1
}

startNetwatcher()
{
    local nwpid
    local -i tret

    if [[ ${forcepoll} -eq 0 ]]
    then
        return 1
    fi

    nwpid=$(netwatcherRunning)
    tret=$?
    if [[ ${tret} -ne 0 ]]
    then
        "${netwatcher}" >/dev/null 2>&1 </dev/null &
        echo $! > "${datadir}/${tmpdir}/${nwpidfile}" 2>/dev/null
        nwpid=$(waitforNetwatcherRunning)
        tret=$?
    fi
    if [[ ${tret} -eq 0 ]]
    then
        echo "${nwpid}"
        return 0
    fi

    return 1
}

stopNetwatcher()
{
    local nwpid

    if [[ ${forcepoll} -eq 0 ]]
    then
        return 1
    fi

    NWpid=0
    if nwpid=$(netwatcherRunning)
    then
        kill -KILL "${nwpid}" >& /dev/null
        rm -f "${datadir}/${tmpdir}/${nwpidfile}" >& /dev/null
    fi

    return 0
}

sleepwatcherRunning()
{
    local spid
    local rpid
    local -i npid

    if [[ ${forcepoll} -eq 0 ]]
    then
        return 3
    fi

    if [[ ${useSW} -ne 0 ]]
    then
        return 4
    fi

    if [[ ${intr} -eq 0 ]]
    then
        return ${rintr}
    fi

    if checkFileR "${datadir}/${tmpdir}/${swpidfile}"
    then
        spid=$(cat "${datadir}/${tmpdir}/${swpidfile}")
        if [[ "${spid}" == "" ]]
        then
            rm -f "${datadir}/${tmpdir}/${swpidfile}" >& /dev/null
            spid="0"
        fi
    fi

    rpid=$(pgrep -f -u "${myuid}" "${sleepwatcher} --pidfile ${datadir}/${tmpdir}/${swpidfile} --wakeup")
    if [[ "${rpid}" == "" ]]
    then
        rm -f "${datadir}/${tmpdir}/${swpidfile}" >& /dev/null
        npid=0
    else
        npid=$(echo "${rpid}" | wc -l | awk '{ print $1 }')
    fi
    if [[ ${npid} -eq 0 ]]
    then
        rm -f "${datadir}/${tmpdir}/${swpidfile}" >& /dev/null
        return 1
    elif [[ ${npid} -eq 1 ]]
    then
        if [[ "${spid}" != "${rpid}" ]]
        then
            echo "${rpid}" > "${datadir}/${tmpdir}/${swpidfile}" 2> /dev/null
        fi
        echo "${rpid}"
        return 0
    fi

    return 2
}

waitforSleepwatcherRunning()
{
    local -i n=0
    local swpid

    while [[ ${n} -lt 30 ]]
    do
        if swpid=$(sleepwatcherRunning)
        then
            echo "${swpid}"
            return 0
        fi
        if [[ ${intr} -eq 0 ]]
        then
            return ${rintr}
        fi
        sleep 1
        n=${n}+1
    done

    return 1
}

startSleepwatcher()
{
    local swpid
    local -i tret

    if [[ ${forcepoll} -eq 0 ]]
    then
        return 1
    fi

    if ! checkSleepwatcher
    then
        return 2
    fi


    swpid=$(sleepwatcherRunning)
    tret=$?
    if [[ ${tret} -ne 0 ]]
    then
        if [[ ${enablePower} -eq 0 ]]
        then
            "${sleepwatcher}" --pidfile "${datadir}/${tmpdir}/${swpidfile}" --wakeup "'${mypath}' _zzwake" --sleep "'${mypath}' _zzsleep" --plug "'${mypath}' _zzacpower" --unplug "'${mypath}' _zzbattery" >/dev/null 2>&1 </dev/null &
        else
            "${sleepwatcher}" --pidfile "${datadir}/${tmpdir}/${swpidfile}" --wakeup "'${mypath}' _zzwake" --sleep "'${mypath}' _zzsleep" >/dev/null 2>&1 </dev/null &
        fi
        swpid=$(waitforSleepwatcherRunning)
        tret=$?
    fi
    if [[ ${tret} -eq 0 ]]
    then
        echo "${swpid}"
        return 0
    fi

    return ${tret}
}

stopSleepwatcher()
{
    local swpid

    if [[ ${forcepoll} -eq 0 ]]
    then
        return 1
    fi

    SWpid=0
    if [[ ${useSW} -ne 0 ]]
    then
        return 0
    fi

    if swpid=$(sleepwatcherRunning)
    then
        kill -KILL "${swpid}" >& /dev/null
        rm -f "${datadir}/${tmpdir}/${swpidfile}" >& /dev/null
    fi

    return 0
}

clearEvent()
{
    eventTS=0
    rm -f "${datadir}/${tmpdir}/${nwchangefile}" >& /dev/null
    return 0
}

checkEvent()
{
    local -i ts
    local -i event=1

    if [[ ${forcepoll} -ne 0 ]] && [[ ${inSleep} -ne 0 ]]
    then
        if [[ ${eventTS} -gt 0 ]]
        then
            event=0
        elif checkFileR "${datadir}/${tmpdir}/${nwchangefile}"
        then
            eventTS=$(date '+%s')
            event=0
        fi
    fi

    return ${event}
}

checkDeadchild()
{
    local -i ret=1

    if [[ ${forcepoll} -eq 0 ]]
    then
        return 1
    fi

    if [[ ${useSW} -eq 0 ]] && [[ ${SWpid} -ne 0 ]]
    then
        if ! pgrep -q -f -u "${myuid}" "${sleepwatcher} --pidfile ${datadir}/${tmpdir}/${swpidfile} --wakeup" 
        then
            SWpid=0
            ret=0
        fi
    fi
    if [[ ${NWpid} -ne 0 ]]
    then
        if ! pgrep -q -f -u "${myuid}" "${netwatcher}"
        then
            NWpid=0
            ret=0
        fi
    fi
    return ${ret}
}

initPower()
{
    local -i tret=0

    if [[ ${enablePower} -eq 1 ]]
    then
        rm -f "${datadir}/${tmpdir}/${batteryfile}" >& /dev/null
        rm -f "${datadir}/${tmpdir}/${acpowerfile}" >& /dev/null
        return 0
    fi

    pmset -g ac | grep -q 'No adapter'
    tret=$?
    if [[ $# -gt 0 ]]
    then
        powerTS=$(date '+%s')
        rm -f "${datadir}/${tmpdir}/${batteryfile}" >& /dev/null
        rm -f "${datadir}/${tmpdir}/${acpowerfile}" >& /dev/null
        if [[ ${tret} -eq 0 ]]
        then
            checkFileRW "${datadir}/${tmpdir}/${batteryfile}" Y
            curBattery=0
            prvBattery=1
        else
            checkFileRW "${datadir}/${tmpdir}/${acpowerfile}" Y
            curBattery=1
            prvBattery=0
        fi
    else
        if [[ ${tret} -eq 1 ]]
        then
            checkFileRW "${datadir}/${tmpdir}/${acpowerfile}" Y
            curBattery=1
        else
            checkFileRW "${datadir}/${tmpdir}/${batteryfile}" Y
            curBattery=0
        fi
        if [[ ${curBattery} -ne ${prvBattery} ]]
        then
            powerTS=$(date '+%s')
        fi
    fi
    return 0
}

clearPower()
{
    powerTS=0
    if [[ ${curBattery} -eq 0 ]]
    then
        rm -f "${datadir}/${tmpdir}/${acpowerfile}" >& /dev/null
    else
        rm -f "${datadir}/${tmpdir}/${batteryfile}" >& /dev/null
    fi
    return 0
}

checkPower()
{
    local -i pevent=1

    if [[ ${enablePower} -eq 1 ]]
    then
        return 1
    fi

    if [[ ${powerTS} -gt 0 ]]
    then
        pevent=0
    elif [[ ${useSW} -eq 0 ]] && [[ ${forcepoll} -ne 0 ]] && [[ ${inSleep} -ne 0 ]]
    then
        if checkFileR "${datadir}/${tmpdir}/${batteryfile}"
        then
            if [[ ${curBattery} -eq 1 ]]
            then
                pevent=0
                curBattery=0
                powerTS=$(date '+%s')
                rm -f "${datadir}/${tmpdir}/${acpowerfile}" >& /dev/null
            fi
        fi
        if checkFileR "${datadir}/${tmpdir}/${acpowerfile}"
        then
            if [[ ${curBattery} -eq 0 ]]
            then
                pevent=0
                curBattery=1
                powerTS=$(date '+%s')
                rm -f "${datadir}/${tmpdir}/${batteryfile}" >& /dev/null
            fi
        fi
    else
        if pmset -g ac | grep -q 'No adapter'
        then
            if [[ ${curBattery} -eq 1 ]]
            then
                pevent=0
                curBattery=0
                powerTS=$(date '+%s')
                rm -f "${datadir}/${tmpdir}/${acpowerfile}" >& /dev/null
            fi
        else
            if [[ ${curBattery} -eq 0 ]]
            then
                pevent=0
                curBattery=1
                powerTS=$(date '+%s')
                rm -f "${datadir}/${tmpdir}/${batteryfile}" >& /dev/null
            fi
        fi
    fi

    if [[ ${curBattery} -eq 0 ]]
    then
        sleepQuantum=${btSQ}
    else
        sleepQuantum=${acSQ}
    fi

    return ${pevent}
}

clearWake()
{
    slpTS=$(date '+%s')
    dwslpTS=0
    curDW=${slpTS}
    wakeTS=0
    slpDur=0
    rm -f "${datadir}/${tmpdir}/${sleepfile}" >& /dev/null
    rm -f "${datadir}/${tmpdir}/${wakefile}" >& /dev/null
    return 0
}

checkSleep()
{
    local -i sTS=0
    local -i wTS=0
    local -i dw=$1

    if [[ ${useSW} -ne 0 ]] || [[ ${forcepoll} -eq 0 ]]
    then
        return 1
    fi

#   event driven mode
    if [[ ${dw} -eq 0 ]]
    then
        curDW=$(date "+%s")
    fi
    if checkFileR "${datadir}/${tmpdir}/${sleepfile}"
    then
        sTS=$(cat "${datadir}/${tmpdir}/${sleepfile}")
    fi
    if checkFileR "${datadir}/${tmpdir}/${wakefile}"
    then
        wTS=$(cat "${datadir}/${tmpdir}/${wakefile}")
    fi
    if [[ ${sTS} -gt ${wTS} ]] && [[ ${sTS} -gt ${slpTS} ]]
    then
#       system is supposedly going to sleep
        inSleep=0
        slpTS=${sTS}
        dwslpTS=${slpTS}
        wakeTS=0
        pendingDwTs=0
        return 0
    fi

    return 1
}

checkDarkWake()
{
    local ts
    local dur
    local -i delta

    if [[ ${pendingDwTs} -gt 0 ]]
    then
        delta=${curDW}-${pendingDwTs}
        if [[ ${delta} -gt ${minDarkWakeLag} ]]
        then
            ts=$(cvtTS "${curDW}")
            pendingDwTs=0
            if [[ ${dwslpTS} -gt 0 ]]
            then
                delta=${curDW}-${dwslpTS}
                dur=$(fmtInterval "${delta}")
                logMsg "dark wake at ${ts} (sleep duration was ${dur})"
            else
                logMsg "dark wake at ${ts}"
            fi
            dwslpTS=0
        fi
    fi
    if [[ ${inDW} -eq 0 ]]
    then
        delta=${curDW}-${prvDW}
        if [[ ${delta} -gt ${dwInterval} ]]
        then
            dwslpTS=${prvDW}
            ts=$(cvtTS "${prvDW}")
            dur=$(fmtInterval "${delta}")
            logMsg "system slept at ${ts}"
            if [[ ${inSleep} -eq 0 ]]
            then
                ts=$(cvtTS "${curDW}")
                pendingDwTs=$(date "+%s")
            else
                inDW=1
            fi
        fi
    elif [[ ${inSleep} -eq 0 ]]
    then
        delta=${curDW}-${slpTS}
        if [[ ${delta} -gt ${minDarkWakeLag} ]]
        then
            inDW=0
            dwslpTS=${prvDW}
            delta=${curDW}-${prvDW}
            ts=$(cvtTS "${curDW}")
            dur=$(fmtInterval "${delta}")
            pendingDwTs=$(date "+%s")
        fi
    fi
    prvDW=${curDW}
    curDW=$(date "+%s")

    return 0
}

checkWake()
{
    local -i ts
    local -i delta
    local -i wake=1
    local -i dw=$1
    local -i sTS=0
    local -i wTS=0

    if [[ ${useSW} -eq 0 ]] && [[ ${forcepoll} -ne 0 ]]
    then
#       event driven mode
        if checkFileR "${datadir}/${tmpdir}/${sleepfile}"
        then
            sTS=$(cat "${datadir}/${tmpdir}/${sleepfile}")
        fi
        if checkFileR "${datadir}/${tmpdir}/${wakefile}"
        then
            wTS=$(cat "${datadir}/${tmpdir}/${wakefile}")
        fi
        if [[ ${wTS} -gt ${sTS} ]]
        then
#           system has supposedly woken from sleep
            delta=${wTS}-${sTS}
            if [[ ${delta} -lt ${minsleepsecs} ]]
            then
                logMsg "bogus sleep/wake? ${sTS}/${wTS} - ignoring"
                rm -f "${datadir}/${tmpdir}/${sleepfile}" >& /dev/null
                rm -f "${datadir}/${tmpdir}/${wakefile}" >& /dev/null
            else
                wake=0
                inSleep=1
                inDW=1
                pendingDwTs=0
                wakeTS=${wTS}
                if [[ ${sTS} -gt 0 ]]
                then
                    slpDur=${delta}
                else
                    slpDur=0
                fi
            fi
        elif [[ ${wakeTS} -gt 0 ]]
        then
#           pending unhandled wake
            wake=0
        fi
        if [[ ${dw} -eq 0 ]]
        then
            checkDarkWake
        fi
    else
#       poll mode
        if [[ ${wakeTS} -gt 0 ]]
        then
#           pending unhandled wake
            wake=0
        else
            ts=$(date '+%s')
            delta=${ts}-${slpTS}
            if [[ ${delta} -gt ${wakeCheckValue} ]]
            then
                wake=0
                wakeTS=${ts}
            else
                slpTS=${ts}
            fi
        fi
    fi

    return ${wake}
}

setinterrupt()
{
    intr=0
    return 0
}

setrefresh()
{
    refresh=0
    return 0
}

setrescan()
{
    rescan=0
    return 0
}

cleanup()
{
    if [[ "${mypid}" != "" ]]
    then
        rm -f "${mypid}" >& /dev/null
        mypid=""
    fi
    if [[ "${mytmp}" != "" ]]
    then
        rm -rf "${mytmp}" >& /dev/null
        mytmp=""
    fi
    exit "$1"
}

checkFileR()
{
    local f="$1"
    local -i create=1

    if [[ $# -gt 1 ]]
    then
        create=0
    fi

    if [[ -e "${f}" ]]
    then
        if [[ ! -f "${f}" ]]
        then
            return 2
        elif [[ ! -r "${f}" ]]
        then
            if ! chmod u+r "${f}" >& /dev/null
            then
                return 3
            fi
        fi
    else
        if [[ ${create} -eq 1 ]]
        then
            return 1
        else
            if ! touch "${f}" >& /dev/null
            then
                return 4
            fi
            if ! chmod u+r "${f}" >& /dev/null
            then
                return 5
            fi
        fi
    fi

    return 0
}

checkFileRW()
{
    local f="$1"
    local -i create=1

    if [[ $# -gt 1 ]]
    then
        create=0
    fi

    if [[ -e "${f}" ]]
    then
        if [[ ! -f "${f}" ]]
        then
            return 2
        elif [[ ! -r "${f}" ]] || [[ ! -w "${f}" ]]
        then
            if ! chmod u+rw "${f}" >& /dev/null
            then
                return 2
            fi
        fi
    else
        if [[ ${create} -eq 1 ]]
        then
            return 1
        else
            if ! touch "${f}" >& /dev/null
            then
                return 4
            fi
            if ! chmod u+rw "${f}" >& /dev/null
            then
                return 5
            fi
        fi
    fi

    return 0
}

checkFileRX()
{
    local f="$1"
    local -i create=1

    if [[ $# -gt 1 ]]
    then
        create=0
    fi

    if [[ -e "${f}" ]]
    then
        if [[ ! -f "${f}" ]]
        then
            return 2
        elif [[ ! -r "${f}" ]] || [[ ! -x "${f}" ]]
        then
            if ! chmod u+rx "${f}" >& /dev/null
            then
                return 3
            fi
        fi
    else
        if [[ ${create} -eq 1 ]]
        then
            return 1
        else
            if ! touch "${f}" >& /dev/null
            then
                return 4
            fi
            if ! chmod u+rx "${f}" >& /dev/null
            then
                return 5
            fi
        fi
    fi

    return 0
}

checkFileRWX()
{
    local f="$1"
    local -i create=1

    if [[ $# -gt 1 ]]
    then
        create=0
    fi

    if [[ -e "${f}" ]]
    then
        if [[ ! -f "${f}" ]]
        then
            return 2
        elif [[ ! -r "${f}" ]] || [[ ! -w "${f}" ]] || [[ ! -x "${f}" ]]
        then
            if ! chmod u+rwx "${f}" >& /dev/null
            then
                return 3
            fi
        fi
    else
        if [[ ${create} -eq 1 ]]
        then
            return 1
        else
            if ! touch "${f}" >& /dev/null
            then
                return 4
            fi
            if ! chmod u+rwx "${f}" >& /dev/null
            then
                return 5
            fi
        fi
    fi

    return 0
}

checkDir()
{
    local d="$1"
    local -i create=1

    if [[ $# -gt 1 ]]
    then
        create=0
    fi

    if [[ -e "${d}" ]]
    then
        if [[ ! -d "${d}" ]]
        then
            return 2
        elif [[ ! -r "${d}" ]] || [[ ! -w "${d}" ]] || [[ ! -x "${d}" ]]
        then
            if ! chmod u+rwx "${d}" >& /dev/null
            then
                return 3
            fi
        fi
    else
        if [[ ${create} -eq 1 ]]
        then
            return 1
        else
            if ! mkdir "${d}" >& /dev/null
            then
                return 4
            fi
            if ! chmod u+rwx "${d}" >& /dev/null
            then
                return 5
            fi
        fi
    fi

    return 0
}

isAgent()
{
    if checkFileRW "${datadir}/${cfgdir}/${lanamef}"
    then
        return 0
    else
        return 1
    fi
}

loadConfig()
{
    local tmp
    local -i interactive=1
    local -i ret=0

    if [[ $# -gt 0 ]]
    then
        interactive=0
    fi

    checkFileR "${datadir}/${cfgdir}/${killtimeout}"
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        if [[ ${interactive} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${cfgdir}/${killtimeout}'"
        else
            logMsg "ERROR: unable to access '${datadir}/${cfgdir}/${killtimeout}'"
        fi
        return 2
    elif [[ ${ret} -eq 1 ]]
    then
        cmdkilltimeout=${dfltKillTimeout}
    else
        cmdkilltimeout=$(cat "${datadir}/${cfgdir}/${killtimeout}")
    fi

    checkFileR "${datadir}/${cfgdir}/${warntimeout}"
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        if [[ ${interactive} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${cfgdir}/${warntimeout}'"
        else
            logMsg "ERROR: unable to access '${datadir}/${cfgdir}/${warntimeout}'"
        fi
        return 2
    elif [[ ${ret} -eq 1 ]]
    then
        cmdwarntimeout=${dfltWarnTimeout}
    else
        cmdwarntimeout=$(cat "${datadir}/${cfgdir}/${warntimeout}")
    fi

    checkFileR "${datadir}/${cfgdir}/${acsqfile}"
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        if [[ ${interactive} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${cfgdir}/${acsqfile}'"
        else
            logMsg "ERROR: unable to access '${datadir}/${cfgdir}/${acsqfile}'"
        fi
        return 2
    elif [[ ${ret} -eq 1 ]]
    then
        acSQ=${dfltAcSleepQuantum}
    else
        acSQ=$(cat "${datadir}/${cfgdir}/${acsqfile}")
    fi

    checkFileR "${datadir}/${cfgdir}/${btsqfile}"
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        if [[ ${interactive} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${cfgdir}/${btsqfile}'"
        else
            logMsg "ERROR: unable to access '${datadir}/${cfgdir}/${btsqfile}'"
        fi
        return 2
    elif [[ ${ret} -eq 1 ]]
    then
        btSQ=${dfltBtSleepQuantum}
    else
        btSQ=$(cat "${datadir}/${cfgdir}/${btsqfile}")
    fi

    checkFileR "${datadir}/${cfgdir}/${numlogfile}"
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        if [[ ${interactive} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${cfgdir}/${numlogfile}'"
        else
            logMsg "ERROR: unable to access '${datadir}/${cfgdir}/${numlogfile}'"
        fi
        return 2
    elif [[ ${ret} -eq 1 ]]
    then
        maxlogs=${dfltNumLogs}
    else
        maxlogs=$(cat "${datadir}/${cfgdir}/${numlogfile}")
    fi

    checkFileR "${datadir}/${cfgdir}/${logcyclefile}"
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        if [[ ${interactive} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${cfgdir}/${logcyclefile}'"
        else
            logMsg "ERROR: unable to access '${datadir}/${cfgdir}/${logcyclefile}'"
        fi
        return 2
    elif [[ ${ret} -eq 1 ]]
    then
        logcycle=${dfltLogCycle}
    else
        logcycle=$(cat "${datadir}/${cfgdir}/${logcyclefile}")
    fi

    checkFileR "${datadir}/${tmpdir}/${lastlogcyclefile}"
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        if [[ ${interactive} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${tmpdir}/${lastlogcyclefile}'"
        else
            logMsg "ERROR: unable to access '${datadir}/${tmpdir}/${lastlogcyclefile}'"
        fi
        return 2
    elif [[ ${ret} -eq 1 ]]
    then
        if [[ ${logcycle} -gt 0 ]]
        then
            lastlogcycle=$(date '+%s')
            lastlogcycle=${lastlogcycle}/${secsPerDay}
            echo "${lastlogcycle}" > "${datadir}/${tmpdir}/${lastlogcyclefile}" 2>&1
        fi
    else
        lastlogcycle=$(cat "${datadir}/${tmpdir}/${lastlogcyclefile}")
    fi

    checkFileR "${datadir}/${cfgdir}/${actionlog}"
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        if [[ ${interactive} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${cfgdir}/${actionlog}'"
        else
            logMsg "ERROR: unable to access '${datadir}/${cfgdir}/${actionlog}'"
        fi
        return 2
    elif [[ ${ret} -eq 1 ]]
    then
        actlog=""
    else
        actlog=$(cat "${datadir}/${cfgdir}/${actionlog}")
        tmp="${actlog}"
        if ! checkActionLog
        then
            if [[ ${interactive} -eq 1 ]]
            then
                logMsg "WARNING: action log '${tmp}' not accessible, action logging disabled"
            fi
            return 1
        fi
    fi

    return 0
}

monRefresh()
{
    local -i tret
    local first="$1"
    local nwenv
    local act
    local swpid
    local tmp

    loadConfig
    if [[ $? -gt 1 ]]
    then
        return 1
    fi

    if ! checkFileR "${datadir}/${cfgdir}/${envnames}"
    then
        logMsg "ERROR: unable to access '${datadir}/${cfgdir}/${envnames}'"
        return 2
    fi

    dfltA=""
    dfltI=""
    dfltAN=1
    dfltIN=1
    checkDir "${datadir}/${actdir}/${envDefault}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        logMsg "ERROR: unable to access '${datadir}/${actdir}/${envDefault}'"
        return 3
    elif [[ ${tret} -eq 0 ]]
    then
        for act in a i
        do
            checkFileR "${datadir}/${actdir}/${envDefault}/${act}/${cmdfile}"
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                logMsg "ERROR: unable to access '${datadir}/${actdir}/${envDefault}/${act}/${cmdfile}'"
                return 4
            elif [[ ${tret} -eq 0 ]]
            then
                if [[ "${act}" == "a" ]]
                then
                    dfltA=$(cat "${datadir}/${actdir}/${envDefault}/${act}/${cmdfile}")
                else
                    dfltI=$(cat "${datadir}/${actdir}/${envDefault}/${act}/${cmdfile}")
                fi
            fi
            checkFileR "${datadir}/${actdir}/${envDefault}/${act}/${notifyfile}"
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                logMsg "ERROR: unable to access '${datadir}/${actdir}/${envDefault}/${act}/${notifyfile}'"
                return 4
            elif [[ ${tret} -eq 0 ]]
            then
                if [[ "${act}" == "a" ]]
                then
                    dfltAN=0
                else
                    dfltIN=0
                fi
            fi
        done
    fi

    wakeA=""
    wakeAN=1
    checkDir "${datadir}/${actdir}/${envWake}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        logMsg "ERROR: unable to access '${datadir}/${actdir}/${envWake}'"
        return 3
    elif [[ ${tret} -eq 0 ]]
    then
        for act in a
        do
            checkFileR "${datadir}/${actdir}/${envWake}/${act}/${cmdfile}"
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                logMsg "ERROR: unable to access '${datadir}/${actdir}/${envWake}/${act}/${cmdfile}'"
                return 4
            elif [[ ${tret} -eq 0 ]]
            then
                wakeA=$(cat "${datadir}/${actdir}/${envWake}/${act}/${cmdfile}")
            fi
            checkFileR "${datadir}/${actdir}/${envWake}/${act}/${notifyfile}"
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                logMsg "ERROR: unable to access '${datadir}/${actdir}/${envWake}/${act}/${notifyfile}'"
                return 4
            elif [[ ${tret} -eq 0 ]]
            then
                wakeAN=0
            fi
        done
    fi

    powerA=""
    powerI=""
    powerAN=1
    powerIN=1
    checkDir "${datadir}/${actdir}/${envBattery}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        logMsg "ERROR: unable to access '${datadir}/${actdir}/${envBattery}'"
        return 3
    elif [[ ${tret} -eq 0 ]]
    then
        for act in a i
        do
            checkFileR "${datadir}/${actdir}/${envBattery}/${act}/${cmdfile}"
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                logMsg "ERROR: unable to access '${datadir}/${actdir}/${envBattery}/${act}/${cmdfile}'"
                return 4
            elif [[ ${tret} -eq 0 ]]
            then
                if [[ "${act}" == "a" ]]
                then
                    powerA=$(cat "${datadir}/${actdir}/${envBattery}/${act}/${cmdfile}")
                else
                    powerI=$(cat "${datadir}/${actdir}/${envBattery}/${act}/${cmdfile}")
                fi
            fi
            checkFileR "${datadir}/${actdir}/${envBattery}/${act}/${notifyfile}"
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                logMsg "ERROR: unable to access '${datadir}/${actdir}/${envBattery}/${act}/${notifyfile}'"
                return 4
            elif [[ ${tret} -eq 0 ]]
            then
                if [[ "${act}" == "a" ]]
                then
                    powerAN=0
                else
                    powerIN=0
                fi
            fi
        done
    fi

    nEnv=0
    while read -r nwenv tmp
    do
        if [[ ${intr} -eq 0 ]]
        then
            return ${rintr}
        fi

        if [[ "${nwenv}" == "" ]] || [[ "${tmp}" != "" ]]
        then
            logMsg "ERROR: invalid data in '${datadir}/${cfgdir}/${envnames}'"
            return 5
        fi
        curEnv[${nEnv}]="${nwenv}"
        curA[${nEnv}]=""
        curI[${nEnv}]=""
        curAN[${nEnv}]=1
        curIN[${nEnv}]=1
        
        checkDir "${datadir}/${actdir}/${nwenv}"
        tret=$?
        if [[ ${tret} -gt 1 ]]
        then
            logMsg "ERROR: unable to access '${datadir}/${actdir}/${nwenv}'"
            return 6
        elif [[ ${tret} -eq 0 ]]
        then
            for act in a i
            do
                checkFileR "${datadir}/${actdir}/${nwenv}/${act}/${cmdfile}"
                tret=$?
                if [[ ${tret} -gt 1 ]]
                then
                    logMsg "ERROR: unable to access '${datadir}/${actdir}/${nwenv}/${act}/${cmdfile}'"
                    return 7
                elif [[ ${tret} -eq 0 ]]
                then
                    if [[ "${act}" == "a" ]]
                    then
                        curA[${nEnv}]=$(cat "${datadir}/${actdir}/${nwenv}/${act}/${cmdfile}")
                    else
                        curI[${nEnv}]=$(cat "${datadir}/${actdir}/${nwenv}/${act}/${cmdfile}")
                    fi
                fi
                checkFileR "${datadir}/${actdir}/${nwenv}/${act}/${notifyfile}"
                tret=$?
                if [[ ${tret} -gt 1 ]]
                then
                    logMsg "ERROR: unable to access '${datadir}/${actdir}/${nwenv}/${act}/${notifyfile}'"
                    return 7
                elif [[ ${tret} -eq 0 ]]
                then
                    if [[ "${act}" == "a" ]]
                    then
                        curAN[${nEnv}]=0
                    else
                        curIN[${nEnv}]=0
                    fi
                fi
            done
        fi

        if [[ "${first}" != "" ]]
        then
            curAct[${nEnv}]=1
            prvAct[${nEnv}]=1
        fi

        nEnv=${nEnv}+1
    done < "${datadir}/${cfgdir}/${envnames}"
    
    rm -f "${datadir}/${tmpdir}/${reffile}" >& /dev/null

    return 0
}

monSleep()
{
    local -i start=0
    local -i now=0
    local -i elapsed=0
    local -i residue=1
    local -i stime=$1
    local -i ievent=$2
    local -i irefresh=$3
    local -i icdeath=$4
    local -i ipower=$5
    local -i dw=$6
    local -i ipause=$7
    
    if [[ ${stime} -gt 0 ]]
    then
        start=$(date '+%s')
        while [[ ${elapsed} -lt ${stime} ]]
        do
            if [[ ${residue} -lt 1 ]]
            then
                logMsg "TEMPORAL ANOMALY: stime = ${stime}, sq = ${sleepQuantum}, start = ${start}, now = ${now}, elapsed = ${elapsed}, residue = ${residue}"
            fi
            if [[ ${residue} -lt ${sleepQuantum} ]]
            then
                sleep "${residue}"
            else
                sleep "${sleepQuantum}"
            fi
            if [[ ${intr} -eq 0 ]]
            then
                return ${rintr}
            fi
            if checkWake ${dw}
            then
                if [[ ${ievent} -eq 0 ]]
                then
                    return 1
                fi
            fi
            if [[ ${ievent} -eq 0 ]]
            then
                if checkEvent
                then
                    return 1
                fi
            fi
            if [[ ${enablePower} -eq 0 ]] && [[ ${ipower} -eq 0 ]]
            then
                if checkPower
                then
                    return 1
                fi
            fi
            if [[ ${irefresh} -eq 0 ]] && [[ ${refresh} -eq 0 ]]
            then
                return 1
            fi
            if [[ ${irefresh} -eq 0 ]] && [[ ${rescan} -eq 0 ]]
            then
                return 1
            fi
            if [[ ${icdeath} -eq 0 ]]
            then
                if checkDeadchild
                then
                    return 1
                fi
            fi
            if [[ ${ipause} -eq 0 ]]
            then
                if checkFileRW "${datadir}/${tmpdir}/${pausefile}"
                then
                    return 1
                fi
            fi
            now=$(date '+%s')
            elapsed=${now}-${start}
            residue=${stime}-${elapsed}
        done
    fi

    return 0
}

monGetActive()
{
    local -i tret=0
    local -i i=0
    local nwenv

    if ! checkFileRW "${datadir}/${tmpdir}/${envfile}" Y
    then
        logMsg "ERROR: unable to access '${datadir}/${tmpdir}/${envfile}'"
        return 1
    fi

    if [[ ${intr} -eq 0 ]]
    then
        return ${rintr}
    fi

    getNwEnv show -all > "${datadir}/${tmpdir}/${envfile}" 2> /dev/null
    tret=$?
    if [[ ${tret} -eq 1 ]]
    then
        echo "${unknownname}" > "${datadir}/${tmpdir}/${envfile}" 2> /dev/null
        tret=0
    elif [[ ${tret} -gt 1 ]]
    then
        logMsg "ERROR: 'getNwEnv' returned an error"
        return 2
    fi

    if [[ ${intr} -eq 0 ]]
    then
        return ${rintr}
    fi

    while [[ ${i} -lt ${nEnv} ]]
    do
        curAct[${i}]=1
        i=${i}+1
    done
    if [[ ${tret} -eq 0 ]]
    then
        while read -r nwenv
        do
            i=0
            while [[ ${i} -lt ${nEnv} ]]
            do
                if [[ "${nwenv}" == "${curEnv[${i}]}" ]]
                then
                    curAct[${i}]=0
                    i=${nEnv}
                else
                    i=${i}+1
                fi
                if [[ ${intr} -eq 0 ]]
                then
                    return ${rintr}
                fi
            done
        done < "${datadir}/${tmpdir}/${envfile}"
    fi

    return 0
}

killPID()
{
    local -i pid
    local -i n=0
    local -i tret=0

    if [[ $# -ne 1 ]]
    then
        return 1
    fi
    if ! isNumeric "$1"
    then
        return 1
    fi
    pid=$1

    kill -TERM "${pid}"
    while kill -0 "${pid}"
    do
        if [[ ${n} -gt 5 ]]
        then
            kill -9 "${pid}"
            return 0
        else 
            monSleep 1 1 1 1 1 1 1
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                return ${rintr}
            fi
        fi
        n=${n}+1
    done

    return 0
}

monExec()
{
    local envnm="$1"
    local act="$2"
    local cmd="$3"
    local res
    local ts
    local -i n=0
    local -i ret
    local -i tret
    local -i cpid
    local -i killed=1
    local -i start
    local -i now
    local -i delta

    cmd=$(echo "${cmd}" | sed -e "s/${subenv}/${envnm}/g" -e "s/${subact}/${act}/g")
    logMsg "action ${envnm}:${act}:${cmd}"
    ts=$(date '+%F %H:%M:%S')
    start=$(date '+%s')
    if checkActionLog
    then
        echo "----------------------------------------" >> "${actlog}" 2>/dev/null
        echo "${ts} initiated ${envnm}:${act}:${cmd}" >> "${actlog}" 2>/dev/null
        eval ${cmd} >>"${actlog}" 2>&1 </dev/null &
    else
        eval ${cmd} >&/dev/null </dev/null &
    fi
    ret=$?
    cpid=$!
    if [[ ${ret} -ne 0 ]]
    then
        logMsg "result ${ret}"
        if checkActionLog
        then
            echo "${ts} initiation failed ${envnm}:${act}:${cmd} (${ret})" >> "${actlog}" 2>/dev/null
        fi
        return 0
    fi
    while kill -0 ${cpid} >& /dev/null
    do
        monSleep 1 1 1 1 1 1 1
        tret=$?
        if [[ ${tret} -gt 1 ]]
        then
            killPID ${cpid}
            return ${rintr}
        fi
        n=${n}+1
        now=$(date '+%s')
        delta=${now}-${start}
        if [[ ${cmdkilltimeout} -gt 0 ]] && [[ ${delta} -gt ${cmdkilltimeout} ]]
        then
            killPID ${cpid}
            killed=0
            logMsg "ERROR: command execution exceeded ${cmdkilltimeout} seconds - KILLED"
            if checkActionLog
            then
                echo "${ts} KILLED ${envnm}:${act}:${cmd} (execution exceeded timeout)" >> "${actlog}" 2>/dev/null
            fi
        fi
    done
    wait ${cpid}
    ret=$?
    now=$(date '+%s')
    delta=${now}-${start}
    logMsg "result ${ret}, execution took ${delta} seconds"
    ts=$(date '+%F %H:%M:%S')
    if checkActionLog
    then
        echo "${ts} completed ${envnm}:${act}:${cmd} (${ret})" >> "${actlog}" 2>/dev/null
    fi
    if [[ ${cmdwarntimeout} -gt 0 ]] && \
       [[ ${delta} -gt ${cmdwarntimeout} ]] && \
       [[ ${killed} -eq 1 ]]
    then
        logMsg "WARNING: command execution exceeded ${cmdwarntimeout} seconds"
        if checkActionLog
        then
            echo "${ts} WARNING: command execution exceeded ${cmdwarntimeout} seconds" >> "${actlog}" 2>/dev/null
        fi
    fi

    return 0
}

monDoPower()
{
    local -i notify=$1
    local -i nf=1
    local envnm
    local act
    local msg
    local cmd

    if [[ ${enablePower} -eq 1 ]]
    then
        return 0
    fi

    envnm="${envBattery}"
    if [ ${curBattery} -eq 0 ]
    then
        msg="${envnm} became Active"
        act=A
        logMsg "${msg}"
        if [[ ${powerAN} -eq 0 ]]
        then
            nf=0
        fi
        if [[ "${powerA}" != "" ]]
        then
            cmd="${powerA}"
            nf=${powerAN}
        fi
        if [[ "${cmd}" == "" ]] && [[ ${nf} -eq 1 ]]
        then
            cmd="${dfltA}"
            nf=${dfltAN}
        fi
        if [[ ${nf} -eq 0 ]] && [[ ${notify} -eq 0 ]]
        then
            sendNotification "${msg}"
        fi
        if [[ "${cmd}" != "" ]]
        then
            monExec "${envnm}" "${act}" "${cmd}"
        fi
    else
        msg="${envnm} became Inactive"
        act=I
        logMsg "${msg}"
        if [[ ${powerIN} -eq 0 ]]
        then
            nf=0
        fi
        if [[ "${powerI}" != "" ]]
        then
            cmd="${powerI}"
            nf=${powerIN}
        fi
        if [[ "${cmd}" == "" ]] && [[ ${nf} -eq 1 ]]
        then
            cmd="${dfltI}"
            nf=${dfltIN}
        fi
        if [[ ${nf} -eq 0 ]] && [[ ${notify} -eq 0 ]]
        then
            sendNotification "${msg}"
        fi
        if [[ "${cmd}" != "" ]]
        then
            monExec "${envnm}" "${act}" "${cmd}"
        fi
    fi
    logMsg "sleep quantum is now ${sleepQuantum}"
    if [[ ${intr} -eq 0 ]]
    then
        return ${rintr}
    fi

    return 0
}

monDoWake()
{
    local -i notify=$1
    local -i nf=1
    local envnm
    local act
    local msg
    local cmd

    envnm="${envWake}"
    msg="${envnm} became Active"
    act=A
    logMsg "${msg}"
    if [[ ${wakeAN} -eq 0 ]]
    then
        nf=0
    fi
    if [[ "${wakeA}" != "" ]]
    then
        cmd="${wakeA}"
        nf=${wakeAN}
    fi
    if [[ "${cmd}" == "" ]] && [[ ${nf} -eq 1 ]]
    then
        cmd="${dfltA}"
        nf=${dfltAN}
    fi
    if [[ ${nf} -eq 0 ]] && [[ ${notify} -eq 0 ]]
    then
        sendNotification "${msg}"
    fi
    if [[ "${cmd}" != "" ]]
    then
        monExec "${envnm}" "${act}" "${cmd}"
    fi
    if [[ ${intr} -eq 0 ]]
    then
        return ${rintr}
    fi

    return 0
}

monDoActions()
{
    local -i i=0
    local -i tmp
    local -i notify=$1
    local -i bcheck=$2
    local envnm
    local act
    local -i nf=1
    local -i change=1
    local cmd
    local msg

    i=0
    while [[ ${i} -lt ${nEnv} ]]
    do
        cmd=""
        nf=1
        tmp=${curAct[${i}]}
        if [[ ${prvAct[i]} -ne ${tmp} ]]
        then
            change=0
            envnm="${curEnv[${i}]}"
            if [[ ${tmp} -eq 1 ]]
            then
                msg="${envnm} became Inactive"
                act=I
                logMsg "${msg}"
                if [[ ${curIN[${i}]} -eq 0 ]]
                then
                    nf=0
                fi
                if [[ "${curI[${i}]}" != "" ]]
                then
                    cmd="${curI[${i}]}"
                    nf=${curIN[${i}]}
                fi
                if [[ "${cmd}" == "" ]] && [[ ${nf} -eq 1 ]]
                then
                    cmd="${dfltI}"
                    nf=${dfltIN}
                fi
            fi
            if [[ ${nf} -eq 0 ]] && [[ ${notify} -eq 0 ]]
            then
                sendNotification "${msg}"
            fi
            if [[ "${cmd}" != "" ]]
            then
                monExec "${envnm}" "${act}" "${cmd}"
            fi
        fi
        if [[ ${intr} -eq 0 ]]
        then
            return ${rintr}
        fi
        i=${i}+1
    done

    i=0
    while [[ ${i} -lt ${nEnv} ]]
    do
        cmd=""
        nf=1
        tmp=${curAct[${i}]}
        if [[ ${prvAct[i]} -ne ${tmp} ]]
        then
            change=0
            envnm="${curEnv[${i}]}"
            if [[ ${tmp} -eq 0 ]]
            then
                msg="${envnm} became Active"
                act=A
                logMsg "${msg}"
                if [[ ${curAN[${i}]} -eq 0 ]]
                then
                    nf=0
                fi
                if [[ "${curA[${i}]}" != "" ]]
                then
                    cmd="${curA[${i}]}"
                    nf=${curAN[${i}]}
                fi
                if [[ "${cmd}" == "" ]] && [[ ${nf} -eq 1 ]]
                then
                    cmd="${dfltA}"
                    nf=${dfltAN}
                fi
            fi
            if [[ ${nf} -eq 0 ]] && [[ ${notify} -eq 0 ]]
            then
                sendNotification "${msg}"
            fi
            if [[ "${cmd}" != "" ]]
            then
                monExec "${envnm}" "${act}" "${cmd}"
            fi
        fi
        if [[ ${intr} -eq 0 ]]
        then
            return ${rintr}
        fi
        i=${i}+1
    done

    if [[ ${nwnoop} -eq 0 ]] && [[ ${bcheck} -eq 0 ]] && [[ ${change} -eq 1 ]]
    then
        logMsg "noop network event - ignoring"
    fi

    return 0
}

createNetwatcher()
{
    netwatcher="${datadir}/${bindir}/${nwname}"
    if ! checkFileRWX "${netwatcher}" Y
    then
        return 2
    fi

    cat - > "${netwatcher}" 2>/dev/null <<EOF
#!/usr/bin/python

import os
import signal
import sys
from Foundation import *
from SystemConfiguration import *

fpath = "${datadir}/${tmpdir}/${nwchangefile}"

def touch(path):
    basedir = os.path.dirname(path)
    if not os.path.exists(basedir):
        os.makedirs(basedir)
    open(path, 'w').close()

def callback(store, keys, info):
  touch(fpath)

store = SCDynamicStoreCreate(None,
                             "global-network-watcher",
                             callback,
                             None)
SCDynamicStoreSetNotificationKeys(store,
                                  None,
                                  ['State:/Network/Interface/.*/IPv.'])
CFRunLoopAddSource(CFRunLoopGetCurrent(),
                   SCDynamicStoreCreateRunLoopSource(None, store, 0),
                   kCFRunLoopCommonModes)
CFRunLoopRun()

EOF
    if [[ $? -ne 0 ]]
    then
        return 1
    fi
    if ! chmod 755 "${netwatcher}" >& /dev/null
    then
        return 1
    fi
    
    return 0
}

init()
{
    local -i t1
    local -i t2
    local tmp

    if ! command -v getNwEnv >&/dev/null
    then
        echo >&2 "error: the 'getNwEnv' utility is not in your PATH"
        exit 99
    fi
    if command -v terminal-notifier >&/dev/null
    then
        notifier="terminal-notifier"
    fi
    if [[ ${forcepoll} -ne 0 ]]
    then
        checkSleepwatcher
    fi

    if ! checkDir "${datadir}" Y
    then
        echo >&2 "error: init failed for '${datadir}'"
        exit 97
    fi
    if ! checkDir "${datadir}/${bindir}" Y
    then
        echo >&2 "error: init failed for '${datadir}/${bindir}'"
        exit 96
    fi
    if ! checkDir "${datadir}/${cfgdir}" Y
    then
        echo >&2 "error: init failed for '${datadir}/${cfgdir}'"
        exit 95
    fi
    if ! checkDir "${datadir}/${actdir}" Y
    then
        echo >&2 "error: init failed for '${datadir}/${actdir}'"
        exit 94
    fi
    if ! checkDir "${datadir}/${tmpdir}" Y
    then
        echo >&2 "error: init failed for '${datadir}/${tmpdir}'"
        exit 93
    fi
    if ! checkDir "${datadir}/${logdir}" Y
    then
        echo >&2 "error: init failed for '${datadir}/${logdir}'"
        exit 92
    fi

    if ! createNetwatcher
    then
        echo >&2 "error: failed to create 'netwatcher'"
        exit 91
    fi

    checkFileRW "${datadir}/${cfgdir}/${envnames}"
    t1=$?
    checkFileRW "${datadir}/${cfgdir}/${envdescs}"
    t2=$?
    if [[ ${t1} -gt 1 ]] || [[ ${t2} -gt 1 ]]
    then
        echo >&2 "error: failed to initialise environment list"
        exit 90
    elif [[ ${t1} -ne 0 ]] || [[ ${t2} -ne 0 ]]
    then
        checkFileRW "${datadir}/${cfgdir}/${envnames}" Y
        t1=$?
        checkFileRW "${datadir}/${cfgdir}/${envdescs}" Y
        t2=$?
        if [[ ${t1} -ne 0 ]] || [[ ${t2} -ne 0 ]]
        then
            echo >&2 "error: failed to initialise environment list"
            exit 90
        fi
        if ! getNwEnv list >"${datadir}/${cfgdir}/${envnames}" 2>/dev/null
        then
            echo >&2 "error: failed to initialise environment list"
            exit 90
        fi
        echo "${unknownname}" >>"${datadir}/${cfgdir}/${envnames}" 2>/dev/null
        if ! getNwEnv list -verbose >"${datadir}/${cfgdir}/${envdescs}" 2>/dev/null
        then
            echo >&2 "error: failed to initialise environment list"
            exit 90
        fi
        echo "${unknownname}:${unknowndesc}" >>"${datadir}/${cfgdir}/${envdescs}" 2>/dev/null
    fi

    return 0
}

initTmp()
{
    if ! mytmp=$(mktemp -d -q "${datadir}/${tmpdir}/new.XXXXX")
    then
        echo >&2 "error: failed to create temporary directory"
        return 1
    fi
    return 0
}

listActions()
{
    local envs
    local en
    local ev
    local cmd
    local notify
    local nfopt
    local -i script=1
    local -i ret=0
    local -i tret=0

    if [[ $# -gt 1 ]]
    then
        usage list
    fi
    if [[ $# -eq 1 ]]
    then
        if [[ "$1" == "-script" ]]
        then
            script=0
        else
            usage list
        fi
    fi

    if ! cd "${datadir}/${actdir}" >& /dev/null
    then
        echo >&2 "error: unable to access '${datadir}/${actdir}'"
        return 1
    fi

    if [[ ${script} -eq 0 ]]
    then
        echo "'${me}' clear ${envAll} b"
    fi

    envs=$(ls)
    if [[ "${envs}" == "" ]]
    then
        return 0
    fi

    for en in ${envs}
    do
        for ev in a i
        do
	    checkFileR "${en}/${ev}/${notifyfile}"
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                echo >&2 "error: unable to access '${en}/${ev}/${cmdfile}'"
                ret=1
            elif [[ ${tret} -eq 0 ]]
            then
                notify=n
                nfopt="-notify "
            else
                notify=s
                nfopt="-silent "
            fi

            checkFileRX "${en}/${ev}/${cmdfile}"
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                echo >&2 "error: unable to access '${en}/${ev}/${cmdfile}'"
                ret=1
            elif [[ ${tret} -eq 0 ]]
            then
                cmd=$(cat "${en}/${ev}/${cmdfile}")
                if [[ "${notify}" == "n" ]]
                then
                    nfopt=""
                fi
            else
                cmd=""
            fi

            if [[ "${notify}" != "s" ]] || [[ "${cmd}" != "" ]]
            then
                if [[ ${script} -eq 0 ]]
                then
                    echo "'${me}' set ${en} ${ev} ${nfopt}${cmd}"
                else
                    echo "${en} ${ev} ${notify} ${cmd}"
                fi
            fi
            
        done
    done

    return ${ret}
}

listActive()
{
    if [[ $# -ne 0 ]]
    then
        usage list
    fi

    if ! doStatus >& /dev/null
    then
        echo >&2 "error: no running monitor"
        return 1
    fi

    if [[ ${enablePower} -eq 0 ]]
    then
        if checkFileR "${datadir}/${tmpdir}/${batteryfile}"
        then
            echo "${envBattery}"
        fi
    fi
    if checkFileR "${datadir}/${tmpdir}/${envfile}"
    then
        cat "${datadir}/${tmpdir}/${envfile}"
    fi

    return 0
}

listEnvironments()
{
    local f
    local -i ret=0
    local -i tret=0

    if [[ $# -gt 1 ]]
    then
        usage list
    fi
    if [[ $# -eq 1 ]]
    then
        if [[ "$1" != "-verbose" ]]
        then
            usage list
        fi
    fi

    if [[ "$1" == "-verbose" ]]
    then
        f="${datadir}/${cfgdir}/${envdescs}"
    else
        f="${datadir}/${cfgdir}/${envnames}"
    fi
    checkFileR "${f}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to access '${f}'"
        ret=2
    elif [[ ${tret} -eq 1 ]]
    then
        echo >&2 "error: '${f}' not present"
        ret=1
    else
        if [[ "$1" == "-verbose" ]]
        then
            echo "${envWake}:${envWakeDesc}"
            if [[ ${enablePower} -eq 0 ]]
            then
                echo "${envBattery}:${envBatteryDesc}"
            fi
        else
            echo "${envWake}"
            if [[ ${enablePower} -eq 0 ]]
            then
                echo "${envBattery}"
            fi
        fi
        cat "${f}"
        if [[ "$1" == "-verbose" ]]
        then
            echo "${envDefault}:${envDefaultDesc}"
            echo "${envAll}:${envAllDesc}"
        else
            echo "${envDefault}"
            echo "${envAll}"
        fi
    fi

    return ${ret}
}

doList()
{
    local -i ret=0

    case "$1" in
        "environments")
            shift
            listEnvironments "$@"
            ret=$?
            ;;
        "actions")
            shift
            listActions "$@"
            ret=$?
            ;;
        "active")
            shift
            listActive "$@"
            ret=$?
            ;;
        *)
            usage list
            ;;
    esac

    return ${ret}
}

getMonitorPID()
{
    local -a mpid
    local -a ppid
    local -i npid=0
    local tpid
    local tppid

    while read -r tpid tppid
    do
        mpid[${npid}]="${tpid}"
        ppid[${npid}]="${tppid}"
        npid=${npid}+1
    done
    if [[ ${npid} -eq 0 ]]
    then
        return 0
    fi
    if [[ ${npid} -eq 1 ]]
    then
        echo "${mpid[0]}"
        return 0
    fi
    if [[ ${npid} -gt 2 ]]
    then
        echo >&2 "multiple monitor tasks running"
        return 1
    fi
    if [[ "${mpid[1]}" -eq "${ppid[0]}" ]]
    then
       echo "${mpid[1]}"
       return 0
    elif [[ "${mpid[0]}" -eq "${ppid[1]}" ]]
    then
       echo "${mpid[0]}"
       return 0
    else
         echo >&2 "multiple monitor tasks running"
         return 1
    fi
}

verboseStatus()
{
    local spid=""
    local rpid=""
    local -i n=0
    local -i disp=0
    local -i npid=0
    local -i ret=0

    if [[ $# -eq 1 ]]
    then
        disp=$1
    fi
    if [[ ${useSW} -eq 1 ]] || [[ ${forcepoll} -eq 0 ]]
    then
        if [[ ${disp} -eq 0 ]]
        then
            echo "info: sleepwatcher not in use"
            ret=1
        fi
    else
        if checkFileR "${datadir}/${tmpdir}/${swpidfile}"
        then
            spid=$(cat "${datadir}/${tmpdir}/${swpidfile}")
        fi
        n=0
        while [[ ${n} -lt 5 ]]
        do
            rpid=$(pgrep -f -u "${myuid}" "${sleepwatcher} --pidfile ${datadir}/${tmpdir}/${swpidfile} --wakeup")
            if [[ "${rpid}" == "" ]]
            then
                break
            else
                npid=$(echo "${rpid}" | wc -l | awk '{ print $1 }')
                if [[ ${npid} -eq 1 ]]
                then
                    break
                fi
            fi
            sleep 1
            n=${n}+1
        done
        if [[ "${rpid}" == "" ]]
        then
            if [[ "${spid}" == "" ]]
            then
                if [[ ${disp} -eq 0 ]]
                then
                    echo "info: sleepwatcher is not running"
                    ret=1
                fi
            else
                if [[ ${disp} -eq 0 ]]
                then
                    echo >&2 "error: sleepwatcher state mismatch: stored=running(${spid}), actual=stopped"
                    ret=1
                fi
            fi
        else
            npid=$(echo "${rpid}" | wc -l | awk '{ print $1 }')
            if [[ ${npid} -gt 1 ]]
            then
                if [[ ${disp} -eq 0 ]]
                then
                    echo >&2 "error: multiple sleepwatcher processes detected(${rpid})"
                    ret=1
                fi
            elif [[ "${spid}" == "" ]]
            then
                if [[ ${disp} -eq 0 ]]
                then
                    echo >&2 "error: sleepwatcher state mismatch: stored=stopped, actual=running(${rpid})"
                    ret=1
                fi
            elif [[ "${spid}" != "${rpid}" ]]
            then
                if [[ ${disp} -eq 0 ]]
                then
                    echo >&2 "error: sleepwatcher state mismatch: stored=running(${spid}), actual=running(${rpid})"
                    ret=1
                fi
            else
                if [[ ${disp} -eq 0 ]]
                then
                    echo "info: sleepwatcher is running(${rpid})"
                fi
            fi
        fi
    fi

    if [[ ${forcepoll} -eq 0 ]]
    then
        if [[ ${disp} -eq 0 ]]
        then
            echo "info: netwatcher not in use"
        fi
    else
        if checkFileR "${datadir}/${tmpdir}/${nwpidfile}"
        then
            spid=$(cat "${datadir}/${tmpdir}/${nwpidfile}")
        fi
        n=0
        while [[ ${n} -lt 5 ]]
        do
            rpid=$(pgrep -f -u "${myuid}" "${netwatcher}")
            if [[ "${rpid}" == "" ]]
            then
                break
            else
                npid=$(echo "${rpid}" | wc -l | awk '{ print $1 }')
                if [[ ${npid} -eq 1 ]]
                then
                    break
                fi
            fi
            sleep 1
            n=${n}+1
        done
        if [[ "${rpid}" == "" ]]
        then
            if [[ "${spid}" == "" ]]
            then
                if [[ ${disp} -eq 0 ]]
                then
                    echo "info: netwatcher is not running"
                fi
            else
                if [[ ${disp} -eq 0 ]]
                then
                    echo >&2 "error: netwatcher state mismatch: stored=running(${spid}), actual=stopped"
                fi
            fi
        else
            npid=$(echo "${rpid}" | wc -l | awk '{ print $1 }')
            if [[ ${npid} -gt 1 ]]
            then
                if [[ ${disp} -eq 0 ]]
                then
                    echo >&2 "error: multiple netwatcher processes detected(${rpid})"
                fi
            elif [[ "${spid}" == "" ]]
            then
                if [[ ${disp} -eq 0 ]]
                then
                    echo >&2 "error: netwatcher state mismatch: stored=stopped, actual=running(${rpid})"
                fi
            elif [[ "${spid}" != "${rpid}" ]]
            then
                if [[ ${disp} -eq 0 ]]
                then
                    echo >&2 "error: netwatcher state mismatch: stored=running(${spid}), actual=running(${rpid})"
                fi
            else
                if [[ ${disp} -eq 0 ]]
                then
                    echo "info: netwatcher is running(${rpid})"
                fi
            fi
        fi
    fi

    if checkFileR "${datadir}/${tmpdir}/${reffile}"
    then
        if [[ ${disp} -eq 0 ]]
        then
            echo "info: refresh marked as pending"
        fi
    fi

    return ${ret}
}

sleepStatus()
{
    local -i sTS=0
    local -i wTS=0
    local -i disp=1

    if [[ $# -eq 1 ]]
    then
        disp=$1
    fi

    if checkFileR "${datadir}/${tmpdir}/${sleepfile}"
    then
        sTS=$(cat "${datadir}/${tmpdir}/${sleepfile}")
    fi
    if checkFileR "${datadir}/${tmpdir}/${wakefile}"
    then
        wTS=$(cat "${datadir}/${tmpdir}/${wakefile}")
    fi
    if [[ ${sTS} -gt ${wTS} ]]
    then
#       system is supposedly asleep
        if [[ ${disp} -eq 0 ]]
        then
            echo "info: system is asleep"
        fi
        return 0
    fi

    if [[ ${disp} -eq 0 ]]
    then
        echo "info: system is awake"
    fi
    return 1
}

doStatus()
{
    local -ri maxTries=15
    local spid=""
    local rpid=""
    local plist=""
    local name="monitor"
    local -i verbose=1
    local -i sleepcheck=1
    local -i tryCount=0
    local -i isagent=1
    local -i haveplist=1
    local -i dodisp=1
    local -i ret=0
    local -i tret=0

    while [[ $# -gt 0 ]]
    do
        case "$1" in
            "-verbose")
                if [[ ${verbose} -eq 0 ]]
                then
                    usage status
                fi
                verbose=0
                ;;
            "-asleep")
                if [[ ${sleepcheck} -eq 0 ]]
                then
                    usage status
                fi
                sleepcheck=0
                ;;
            *)
                usage status
                ;;
        esac
        shift
    done

    checkFileRW "${datadir}/${cfgdir}/${lanamef}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${cfgdir}/${lanamef}'"
         fi
        return 7
    elif [[ ${tret} -eq 0 ]]
    then
        isagent=0
        name="agent"
        plist=$(cat "${datadir}/${cfgdir}/${lanamef}")
        plist="${ladir}/${plist}.plist"
        if checkFileRW "${plist}"
        then
            haveplist=0
        fi
    fi
    if [[ ${isagent} -ne ${haveplist} ]]
    then
        if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
        then
            echo >&2 "error: incorrect agent configuration"
        fi
        return 2
    fi

    checkFileRW "${datadir}/${tmpdir}/${pidfile}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${tmpdir}/${pidfile}'"
        fi
        return 6
    elif [[ ${tret} -eq 0 ]]
    then
        spid=$(cat "${datadir}/${tmpdir}/${pidfile}")
    fi

    while [[ ${tryCount} -lt ${maxTries} ]]
    do
        rpid=$(ps -f -u ${myuid} | grep "${me} _zzinternal" | grep -v grep | awk '{ print $2, $3 }' | getMonitorPID 2>&1)
        tret=$?
        if [[ ${tret} -eq 0 ]]
        then
            break
        fi
        tryCount=${tryCount}+1
        sleep 1
    done
    if [[ ${tret} -ne 0 ]]
    then
        if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
        then
            echo >&2 "error: ${rpid}"
        fi
        return 7
    fi

    if [[ "${rpid}" == "" ]]
    then
        if [[ "${spid}" == "" ]]
        then
            echo "info: ${name} is not running"
            ret=1
        else
            if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
            then
                echo >&2 "error: ${name} state mismatch: stored=running(${spid}), actual=stopped"
            fi
            ret=3
        fi
    else
        if [[ "${spid}" == "" ]]
        then
            if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
            then
                echo >&2 "error: ${name} state mismatch: stored=stopped, actual=running(${rpid})"
            fi
            ret=4
        elif [[ "${spid}" != "${rpid}" ]]
        then
            if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
            then
                echo >&2 "error: ${name} state mismatch: stored=running(${spid}), actual=running(${rpid})"
            fi
            ret=5
        else
            if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
            then
                if checkFileRW "${datadir}/${tmpdir}/${pausefile}"
                then
                    echo "info: ${name} is running(${rpid}),paused"
                else
                    echo "info: ${name} is running(${rpid})"
                fi
            fi
            ret=0
        fi
    fi

    tret=1
    if [[ ${ret} -eq 0 ]] && [[ ${verbose} -eq 0 ]] || [[ ${sleepcheck} -eq 0 ]]
    then
        if [[ ${sleepcheck} -ne 0 ]] || [[ ${verbose} -eq 0 ]]
        then
            dodisp=0
        fi
        verboseStatus ${dodisp}
        tret=$?
    fi

    if [[ ${sleepcheck} -eq 0 ]] && [[ ${tret} -eq 0 ]]
    then
        sleepStatus ${verbose}
        ret=$?
    fi

    return ${ret}
}

doHelp()
{
    if [[ $# -eq 0 ]]
    then
        echo
        help_help
        echo
        return 100
    fi

    echo
    while [[ $# -gt 0 ]]
    do
        case "$1" in
            "help")
                help_help
                echo
                ;;
            "full")
                help_full
                echo
                ;;
            "general")
                help_general
                echo
                ;;
            "usage")
                help_usage
                echo
                ;;
            "getnwenv")
                help_getnwenv
                echo
                ;;
            "cleanup")
                help_cleanup
                echo
                ;;
            "clear")
                help_clear
                echo
                ;;
            "config")
                help_config
                echo
                ;;
            "init")
                help_init
                echo
                ;;
            "install")
                help_install
                echo
                ;;
            "list")
                help_list
                echo
                ;;
            "log")
                help_log
                echo
                ;;
            "monitor")
                help_monitor
                echo
                ;;
            "refresh")
                help_refresh
                echo
                ;;
            "rescan")
                help_rescan
                echo
                ;;
            "set")
                help_set
                echo
                ;;
            "start")
                help_start
                echo
                ;;
            "status")
                help_status
                echo
                ;;
            "stop")
                help_stop
                echo
                ;;
            "pause")
                help_pause
                echo
                ;;
            "resume")
                help_resume
                echo
                ;;
            "uninstall")
                help_uninstall
                echo
                ;;
            "version")
                help_version
                echo
                ;;
            *)
                echo "***** invalid help topic '$1' *****"
                echo 
                ;;
        esac
        shift
    done

    return 100
}

doStop()
{
    local res
    local pid=""
    local name="monitor"
    local plist=""
    local -i isagent=1
    local -i count=0
    local -i ret=0

    if [[ $# -ne 0 ]]
    then
        usage stop
    fi

    res=$(doStatus 2>&1)
    ret=$?
    res=$(echo "${res}" | sed -e 's/^[a-z]*: //')

    if isAgent
    then
        isagent=0
        name="agent"
    fi

    case ${ret} in
        0)
            pid=$(echo "${res}" | sed -e 's/^.* running(//' -e 's/).*$//')
            ;;
        1)
            echo "info: ${res}"
            return 0
            ;;
        3)
            rm -f "${datadir}/${tmpdir}/${pidfile}" >& /dev/null
            if [[ -e "${datadir}/${tmpdir}/${pidfile}" ]]
            then
                echo >&2 "error: unable to remove '${datadir}/${tmpdir}/${pidfile}'"
                return 2
            else
                echo "info: ${name} is not running (cleaned up stale state)"
                return 0
            fi
            ;;
        4)
            pid=$(echo "${res}" | sed -e 's/^.* actual=running(//' -e 's/).*$//')
            ;;
        5)
            pid=$(echo "${res}" | sed -e 's/^.* actual=running(//' -e 's/).*$//')
            ;;
        *)
            echo >&2 "error: ${res}"
            return 2
            ;;
    esac

    if [[ ${isagent} -eq 0 ]]
    then
        plist=$(cat "${datadir}/${cfgdir}/${lanamef}")
        plist="${ladir}/${plist}.plist"
        launchctl unload "${plist}" >& /dev/null
    fi
    if [[ "${pid}" == "" ]]
    then
        echo >&2 "error: unable to determine pid of ${name}"
        return 2
    fi
    kill -TERM "${pid}" >& /dev/null

    res=$(doStatus 2>&1)
    ret=$?
    while [[ ${ret} -ne 1 ]] && [[ ${count} -lt 10 ]]
    do
        sleep 1
        res=$(doStatus 2>&1)
        ret=$?
        count=${count}+1
    done

    res=$(echo "${res}" | sed -e 's/^[a-z]*: //')

    if [[ ${ret} -ne 1 ]]
    then
        echo >&2 "error: failed to stop ${name}(${pid}) - ${res}"
        ret=1
    else
        echo "info: stopped ${name}(${pid})"
        ret=0
    fi

    return ${ret}
}

doStart()
{
    local res
    local plist=""
    local -i count=0
    local -i ret=0

    if [[ $# -ne 0 ]]
    then
        usage start
    fi

    if ! isAgent
    then
        echo >&2 "error: agent is not configured"
        return 2
    fi

    res=$(doStatus 2>&1)
    ret=$?
    res=$(echo "${res}" | sed -e 's/^[a-z]*: //')

    if [[ ${ret} -eq 0 ]]
    then
        echo "info: ${res}"
        return 0
    elif [[ ${ret} -ne 1 ]] && [[ ${ret} -ne 3 ]]
    then
        echo >&2 "error: ${res}"
        return 2
    fi

    plist=$(cat "${datadir}/${cfgdir}/${lanamef}")
    plist="${ladir}/${plist}.plist"
    launchctl load "${plist}" >& /dev/null

    res=$(doStatus 2>&1)
    ret=$?
    while [[ ${ret} -ne 0 ]] && [[ ${count} -lt 10 ]]
    do
        sleep 1
        res=$(doStatus 2>&1)
        ret=$?
        count=${count}+1
    done
    res=$(echo "${res}" | sed -e 's/^[a-z]*: //')

    if [[ ${ret} -ne 0 ]]
    then
        echo >&2 "error: failed to start agent - ${res}"
        ret=1
    else
        echo "info: ${res}"
        ret=0
    fi

    return ${ret}
}

doRefresh()
{
    local res
    local pid
    local -i count=0
    local -i force=1
    local -i tret

    if [[ $# -gt 1 ]]
    then
        usage refresh
    fi
    if [[ $# -eq 1 ]]
    then
        if [[ "$1" == "-force" ]]
        then
            force=0
        else
            usage refresh
        fi
    fi

    if [[ ${force} -eq 1 ]]
    then
        if [[ ! -e "${datadir}/${tmpdir}/${reffile}" ]]
        then
            echo "info: nothing to refresh"
            return 0
        fi
    fi

    if ! res=$(doStatus 2>&1)
    then
        res=$(echo "${res}" | sed -e 's/^.*: //')
        echo >&2 "error: ${res}"
        return 1
    fi
    checkFileRW "${datadir}/${tmpdir}/${pidfile}"
    tret=$?
    if [[ ${tret} -ne 0 ]]
    then
        echo >&2 "error: unable to access '${datadir}/${tmpdir}/${pidfile}'"
        return 2
    fi
    pid=$(cat "${datadir}/${tmpdir}/${pidfile}")
    if [[ "${pid}" == "" ]]
    then
        echo >&2 "error: unable to determine pid of monitor"
        return 3
    fi
    if ! kill -USR1 "${pid}" >& /dev/null
    then
        echo >&2 "error: failed to signal refresh to pid ${pid}"
        return 4
    fi

    rm -f "${datadir}/${tmpdir}/${reffile}" >& /dev/null
    if [[ -e "${datadir}/${tmpdir}/${reffile}" ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${tmpdir}/${reffile}'"
        return 5
    fi

    hash -rf >& /dev/null

    echo "info: refreshed monitor(${pid})"

    return 0
}

doRescan()
{
    local res
    local pid
    local -i tret

    if [[ $# -gt 0 ]]
    then
        usage rescan
    fi

    if ! res=$(doStatus 2>&1)
    then
        res=$(echo "${res}" | sed -e 's/^.*: //')
        echo >&2 "error: ${res}"
        return 1
    fi
    checkFileRW "${datadir}/${tmpdir}/${pidfile}"
    tret=$?
    if [[ ${tret} -ne 0 ]]
    then
        echo >&2 "error: unable to access '${datadir}/${tmpdir}/${pidfile}'"
        return 2
    fi
    pid=$(cat "${datadir}/${tmpdir}/${pidfile}")
    if [[ "${pid}" == "" ]]
    then
        echo >&2 "error: unable to determine pid of monitor"
        return 3
    fi
    if ! kill -USR2 "${pid}" >& /dev/null
    then
        echo >&2 "error: failed to signal rescan to pid ${pid}"
        return 4
    fi

    echo "info: rescan request sent to monitor(${pid})"

    return 0
}

shutdown()
{
    local -i notify=$1

    intr=1
    if stopSleepwatcher
    then
        logMsg "sleepwatcher stopped"
    fi
    intr=1
    if stopNetwatcher
    then
        logMsg "netwatcher stopped"
    fi

    rm -f "${datadir}/${actdir}/${sleepfile}" >& /dev/null
    rm -f "${datadir}/${actdir}/${wakefile}" >& /dev/null
    rm -f "${datadir}/${actdir}/${nwchangefile}" >& /dev/null

    logMsg "monitor stopped"
    if [[ ${notify} -eq 0 ]]
    then
        sendNotification "Stopped"
    fi

    return 0
}

logConfigInfo()
{
    logMsg "    warntimeout = ${cmdwarntimeout}"
    logMsg "    killtimeout = ${cmdkilltimeout}"
    logMsg "    maxlogs = ${maxlogs}"
    logMsg "    logrotate = ${logcycle}"
    if [[ "${actlog}" != "" ]]
    then
        logMsg "    action log = '${actlog}'"
    else
        logMsg "    action log = <not defined>"
    fi
    if [[ ${enablePower} -eq 0 ]]
    then
        logMsg "    power source detection enabled"
        logMsg "    battery sleep quantum = ${btSQ}"
    fi
    logMsg "    AC sleep quantum = ${acSQ}"
    return 0
}

logRotateInfo()
{
    logMsg "****************************************"
    logMsg "log rotated by monitor version ${version}, pid = $$"
    if [[ ${notify} -eq 0 ]] && [[ "${notifier}" == "" ]]
    then
        logMsg "WARNING: notifications disabled because 'terminal-notifier' is not installed"
        notify=1
    fi
    logMsg "    settle = ${settle}"
    logMsg "    interval = ${interval}"
    logConfigInfo
    if [[ ${forcepoll} -eq 0 ]]
    then
        logMsg "    forcing use of poll mode (-poll)"
    fi
    if [[ ${SWpid} -ne 0 ]]
    then
        logMsg "sleepwatcher running, pid = ${SWpid}"
    fi
    if [[ ${NWpid} -ne 0 ]]
    then
        logMsg "netwatcher running, pid = ${NWpid}"
    fi
    return 0
}

pauseMonitor()
{
    local tmp
    local -i pauseval
    local -i now
    local -i resumetime
    
    if ! checkFileRW "${datadir}/${tmpdir}/${pausefile}"
    then
        logMsg "ERROR: bogus pause request!"
        return 0
    fi
    tmp=$(cat "${datadir}/${tmpdir}/${pausefile}" 2>/dev/null)
    if ! isnumeric "${tmp}"
    then
        logMsg "ERROR: invalid pause request (${tmp})"
        return 0
    fi
    pauseval=${tmp}
    if [[ ${pauseval} -eq 0 ]]
    then
        pauseval=${foreverPause}
        logMsg "pausing forever..."
    else
        if [[ ${pauseval} -lt ${minPause} ]] || [[ ${pauseval} -gt ${maxPause} ]]
        then
            logMsg "ERROR: pause time out of range (${pauseval})"
            return 0
        fi
        logMsg "pausing for ${pauseval} seconds..."
    fi
    if [[ ${notify} -eq 0 ]]
    then
        sendNotification "Paused"
    fi

    now=$(date "+%s")
    resumetime=$((now+pauseval))
    while [[ ${now} -lt ${resumetime} ]] && checkFileRW "${datadir}/${tmpdir}/${pausefile}"
    do
        monSleep 1 1 1 1 1 1 1
        if [[ $? -eq ${rintr} ]]
        then
            now=${resumetime}
        else
            now=$(date "+%s")
        fi
    done
    rm -f "${datadir}/${tmpdir}/${pausefile}" >& /dev/null
    logMsg "...resuming"
    if [[ ${notify} -eq 0 ]]
    then
        sendNotification "Resumed"
    fi

    if checkFileRW "${datadir}/${tmpdir}/${norescanfile}"
    then
        rm -f "${datadir}/${tmpdir}/${norescanfile}" >& /dev/null
    else
        rescan=0
    fi

    return 0
}

doInternal()
{
    local -ri nwMaxRestarts=5
    local -ri swMaxRestarts=5
    local -i nwRestarts=0
    local -i swRestarts=0
    local -i prvts=0
    local -i curts=0
    local -i delta=0
    local -i tret=0
    local -i ts1=0
    local -i ts2=0
    local -i bcheck=1
    local -i forceCheck=1
    local -i interval=$2
    local -i settle=$3
    local -i notify=$5
    local -i agent=$7
    local -i nwnoop=$8
    local -i dw=$9
    local -i i=0
    local swpid
    local nwpid
    local tmp
    local tmp2

    mylog="$1"
    wakeCheckValue=$4
    forcepoll=$6
    debug=${10}

#
# Initialisation stuff
#
    trap "setinterrupt" INT HUP TERM
    trap "setrefresh" USR1
    trap "setrescan" USR2

    if [[ ${agent} -eq 0 ]]
    then
        cleanupInternal 1
    fi
    rm -f "${datadir}/${tmpdir}/${pausefile}" >& /dev/null

    ts1=$(date '+%s')

    clearWake
    clearEvent

    mypid="${datadir}/${tmpdir}/${pidfile}"
    echo $$ > "${mypid}"

    logMsg "----------------------------------------"
    logMsg "monitor version ${version} started, pid = $$"
    if [[ ${notify} -eq 0 ]] && [[ "${notifier}" == "" ]]
    then
        logMsg "WARNING: notifications disabled because 'terminal-notifier' is not installed"
        notify=1
    fi
    if [[ ${notify} -eq 0 ]]
    then
        sendNotification "Version ${version} started"
    fi

#
# Load configuration
#
    if ! monRefresh Y
    then
        logMsg "monitor stopped"
        if [[ ${notify} -eq 0 ]]
        then
            sendNotification "Stopped"
        fi
        return 0
    fi

    logMsg "    settle = ${settle}"
    logMsg "    interval = ${interval}"
    logConfigInfo
    if [[ ${forcepoll} -eq 0 ]]
    then
        logMsg "    forcing use of poll mode (-poll)"
    fi

#
# Try to start 'sleepwatcher'
#
    if [[ ${forcepoll} -ne 0 ]] && [[ ${useSW} -eq 0 ]]
    then
        swpid=$(startSleepwatcher)
        tret=$?
        if [[ ${tret} -gt 1 ]]
        then
            SWpid=0
            useSW=1
            logMsg "WARNING: sleepwatcher is not available, falling back to polling mechanism"
        elif [[ ${tret} -eq 0 ]]
        then
            SWpid=${swpid}
            logMsg "sleepwatcher started, pid = ${swpid}"
        else
            SWpid=0
            logMsg "ERROR: failed to start sleepwatcher, falling back to polling mechanism"
        fi
        clearWake
    fi

#
# Start 'netwatcher'
#
    if [[ ${forcepoll} -ne 0 ]]
    then
        nwpid=$(startNetwatcher)
        tret=$?
        if [[ ${tret} -eq 0 ]]
        then
            NWpid=${nwpid}
            logMsg "netwatcher started, pid = ${nwpid}"
        else
            NWpid=0
            logMsg "ERROR: failed to start netwatcher, falling back to polling mechanism"
        fi
        clearEvent
    fi

#
# Compute settle time
#
    if [[ ${settle} -eq 0 ]]
    then
        ts2=0
    else
        ts2=$(date '+%s')
        ts1=${ts2}-${ts1}
        ts2=${settle}-${ts1}
        if [[ ${ts2} -lt 0 ]]
        then
           ts2=0
        fi
    fi

#
# Settle
#
    if [[ ${settle} -gt 0 ]]
    then
        logMsg "settling for ${ts2} seconds"
        monSleep ${ts2} 1 1 1 1 1 1
        tret=$?
        if [[ ${tret} -gt 1 ]]
        then
            shutdown "${notify}"
            return 0
        fi
    fi

#
# Register existing state(s)
#

    if [[ ${enablePower} -eq 0 ]]
    then
        initPower Y
        if checkPower
        then
            clearPower
    
            if monDoPower "${notify}"
            then
                prvBattery=${curBattery}
            else
                shutdown "${notify}"
                return 0
            fi
        fi
    fi

    clearEvent
    if ! monGetActive
    then
        shutdown "${notify}"
        return 0
    fi
    if ! monDoActions "${notify}" 1
    then
        shutdown "${notify}"
        return 0
    fi
    prvAct=( ${curAct[@]} )

#
# Main event checking and action loop
#

    while [[ ${intr} -ne 0 ]]
    do
        prvts=$(date '+%s')


        if checkFileRW "${datadir}/${tmpdir}/${pausefile}"
        then
            pauseMonitor
        fi

        if checkFileRW "${datadir}/${tmpdir}/${forcelogcyclefile}"
        then
            autoRotateLogs Y
            if [[ $? -eq 1 ]]
            then
                logRotateInfo
            fi
            rm -f "${datadir}/${tmpdir}/${forcelogcyclefile}" >& /dev/null
        elif [[ ${logcycle} -gt 0 ]]
        then
            autoRotateLogs
            if [[ $? -eq 1 ]]
            then
                logRotateInfo
            fi
        fi

#
# Check if we need to refresh and if so do it.
#
        if [[ ${refresh} -eq 0 ]]
        then
            logMsg "refresh started"
            refresh=1
            if ! monRefresh
            then
                break
            fi
            logConfigInfo
            logMsg "refresh completed"
            if [[ ${notify} -eq 0 ]]
            then
                sendNotification "Refreshed"
            fi
        fi

#
# If 'sleepwatcher' is in use, check that it is running and if not try to restart it
#
        if [[ ${forcepoll} -ne 0 ]]
        then
            if [[ "${sleepwatcher}" != "" ]] && [[ ${SWpid} -ne 0 ]]
            then
                if ! kill -0 ${SWpid} >& /dev/null
                then
                    SWpid=0
                fi
            fi
            if [[ "${sleepwatcher}" != "" ]] && \
               [[ ${SWpid} -eq 0 ]] && \
               [[ ${swRestarts} -le ${swMaxRestarts} ]]
            then
                if [[ ${swRestarts} -eq ${swMaxRestarts} ]]
                then
                    logMsg "ERROR: sleepwatcher restart retries exhausted, using polling mechanism"
                    useSW=1
                else
                    logMsg "ERROR: sleepwatcher is not running!"
                    swpid=$(startSleepwatcher)
                    tret=$?
                    if [[ ${tret} -gt 1 ]]
                    then
                        logMsg "WARNING: sleepwatcher is no longer available, using polling mechanism"
                        useSW=1
                    elif [[ ${tret} -eq 0 ]]
                    then
                        SWpid=${swpid}
                        logMsg "sleepwatcher restarted, pid = ${swpid}"
                    else
                        logMsg "ERROR: failed to restart sleepwatcher, switching to polling mechanism"
                    fi
                fi
                clearWake
                initPower
                swRestarts=${swRestarts}+1
            fi
            if [[ ${intr} -eq 0 ]]
            then
                break
            fi
        fi

#
# Check that 'netwatcher' is running and if not try to restart it
#
        if [[ ${forcepoll} -ne 0 ]]
        then
            if [[ ${NWpid} -ne 0 ]]
            then
                if ! kill -0 ${NWpid} >& /dev/null
                then
                    NWpid=0
                fi
            fi
            if [[ ${NWpid} -eq 0 ]] && [[ ${nwRestarts} -le ${nwMaxRestarts} ]]
            then
                if [[ ${nwRestarts} -eq ${nwMaxRestarts} ]]
                then
                    logMsg "ERROR: netwatcher restart retries exhausted, using polling mechanism"
                else
                    logMsg "ERROR: netwatcher is not running!"
                    nwpid=$(startNetwatcher)
                    tret=$?
                    if [[ ${tret} -eq 0 ]]
                    then
                        NWpid=${nwpid}
                        logMsg "netwatcher restarted, pid = ${nwpid}"
                    else
                        logMsg "ERROR: failed to restart netwatcher, using polling mechanism"
                    fi
                fi
                clearEvent
                nwRestarts=${nwRestarts}+1
            fi
            if [[ ${intr} -eq 0 ]]
            then
                break
            fi
        fi

#
# Check for and handle any wake events
#
        if checkSleep ${dw}
        then
            tmp=$(cvtTS "${slpTS}")
            logMsg "system slept at ${tmp}"
        fi
        if checkWake ${dw}
        then
            tmp=$(cvtTS "${wakeTS}")
            if [[ ${slpDur} -gt 0 ]]
            then
                tmp2=$(fmtInterval ${slpDur})
                logMsg "system woke at ${tmp} (sleep duration was ${tmp2})"
            else
                logMsg "system woke at ${tmp}"
            fi
            forceCheck=0

            if [[ ${settle} -gt 0 ]]
            then
                ts1=$(date '+%s')
                ts1=${ts1}-${wakeTS}
                ts2=${settle}-${ts1}
                if [[ ${SWpid} -gt 0 ]]
                then
                    ts2=${ts2}-${swSettleFactor}
                fi
                if [[ ${ts2} -lt 0 ]]
                then
                   ts2=0
                fi
            else
                ts2=${settle}
            fi

            clearWake
            if [[ ${settle} -gt 0 ]]
            then
                monSleep "${ts2}" 1 1 1 1 1 1
                tret=$?
                if [[ ${tret} -gt 1 ]]
                then
                    break
                fi
                clearEvent
            fi

            if [[ ${wakeAN} -eq 0 ]] || [[ "${wakeA}" != "" ]]
            then
                if ! monDoWake "${notify}"
                then
                    break
                fi
            fi
        fi

#
# Check for and handle any power events
#
        if [[ ${enablePower} -eq 0 ]]
        then
            if checkPower
            then
                clearPower
    
                if ! monDoPower "${notify}"
                then
                    break
                fi
                prvBattery=${curBattery}
    
                if [[ ${intr} -eq 0 ]]
                then
                    break
                fi
            fi
        fi

#
# Check if we need to rescan and if so do it.
#
        if [[ ${rescan} -eq 0 ]]
        then
            logMsg "rescan request received"
            rescan=1
            forceCheck=0
            i=0
            while [[ ${i} -lt ${nEnv} ]]
            do
                prvAct[${i}]=1
                curAct[${i}]=1
                i=${i}+1
            done
            rm -f "${datadir}/${tmpdir}/${norescanfile}" >& /dev/null
        fi

#
# Check for and handle any network events
#
        if [[ ${forcepoll} -ne 0 ]]
        then
            checkEvent
            tret=$?
            if [[ ${tret} -eq 0 ]]
            then
                bcheck=0
            else
                bcheck=1
                if [[ ${forceCheck} -eq 0 ]] && [[ ${inSleep} -eq 1 ]]
                then
                    tret=0
                fi
            fi
        else
            tret=0
            bcheck=1
        fi

        forceCheck=1

        if [[ ${tret} -eq 0 ]] || [[ ${NWpid} -eq 0 ]]
        then
            clearEvent

            if ! monGetActive
            then
                break
            fi

            if [[ ${NWpid} -eq 0 ]]
            then
                bcheck=1
            fi

            if ! monDoActions "${notify}" "${bcheck}"
            then
                break
            fi
    
            prvAct=( ${curAct[@]} )
            if [[ ${intr} -eq 0 ]]
            then
                break
            fi
        fi

#
# Compute 'sleep' time
#
        if [[ ${forcepoll} -eq 0 ]] || \
           [[ ${NWpid} -eq 0 ]] || \
           [[ ${SWpid} -eq 0 ]]
        then
#
# Polling mode
#
            curts=$(date '+%s')
            delta=${curts}-${prvts}
            delta=${interval}-${delta}

        else
#
# Event driven mode
#
            delta=${eventModeSleep}
            dwInterval=${delta}+15
        fi

#
# Interruptible sleep until next poll interval or event
#
        if [[ ${delta} -gt 0 ]]
        then
            monSleep ${delta} 0 0 0 0 ${dw} 0
            tret=$?
            if [[ ${tret} -gt 1 ]]
            then
                break
            elif [[ ${tret} -eq 0 ]]
            then
                forceCheck=0
            fi
        fi

    done

    rm -f "${datadir}/${tmpdir}/${pausefile}" >& /dev/null

    shutdown "${notify}"

    return 0
}

doMonitor()
{
    local -i settle=0
    local -i interval=0
    local -i notify=1
    local -i wakecheck=0
    local -i infg=1
    local -i dw=1
    local -i agent=1
    local -i nwnoop=1
    local -i fsettle=1
    local -i finterval=1
    local -i fnotify=1
    local -i fwakecheck=1
    local -i ffg=1
    local -i fdw=1
    local -i tret
    local pid
    local res

    res=$(doStatus 2>&1)
    tret=$?
    res=$(echo "${res}" | sed -e 's/^[a-z]*: //')
    if [[ ${tret} -ne 1 ]] && [[ ${tret} -ne 3 ]]
    then
        echo >&2 "error: ${res}"
        return 2
    fi

    while [[ $# -gt 0 ]]
    do
        case "$1" in
            "-debug")
                debug=0
                ;;
            "-nonwnoop")
                nwnoop=1
                ;;
            "-nwnoop")
                nwnoop=0
                ;;
            "-poll")
                forcepoll=0
                ;;
            "-agent")
                agent=0
                ;;
#            "-dw")
#                if [[ ${fdw} -eq 0 ]]
#                then
#                    usage monitor
#                fi
#                dw=0
#                fdw=0
#                ;;
#            "-nodw")
#                if [[ ${fdw} -eq 0 ]]
#                then
#                    usage monitor
#                fi
#                dw=1
#                fdw=0
#                ;;
            "-fg")
                if [[ ${ffg} -eq 0 ]]
                then
                    usage monitor
                fi
                infg=0
                ffg=0
                ;;
            "-nonotify")
                if [[ ${fnotify} -eq 0 ]]
                then
                    usage monitor
                fi
                notify=1
                fnotify=0
                ;;
            "-notify")
                if [[ ${fnotify} -eq 0 ]]
                then
                    usage monitor
                fi
                notify=0
                fnotify=0
                ;;
            "-settle")
                if [[ ${fsettle} -eq 0 ]]
                then
                    usage monitor
                fi
                fsettle=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage monitor
                fi
                if ! isNumeric "$1"
                then
                    echo >&2 "error: value for '-settle' must be numeric"
                    return 1
                fi
                settle=$1
                if [[ ${settle} -lt ${minSettle} ]] || [[ ${settle} -gt ${maxSettle} ]]
                then
                    echo >&2 "error: value for '-settle' must be between ${minSettle} and ${maxSettle}"
                    return 1
                fi
                ;;
            "-interval")
                if [[ ${finterval} -eq 0 ]]
                then
                    usage monitor
                fi
                finterval=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage monitor
                fi
                if ! isNumeric "$1"
                then
                    echo >&2 "error: value for '-interval' must be numeric"
                    return 1
                fi
                interval=$1
                if [[ ${interval} -lt ${minInterval} ]] || [[ ${interval} -gt ${maxInterval} ]]
                then
                    echo >&2 "error: value for '-interval' must be between ${minInterval} and ${maxInterval}"
                    return 1
                fi
                ;;
            "-wakecheck")
                if [[ ${fwakecheck} -eq 0 ]]
                then
                    usage monitor
                fi
                fwakecheck=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage monitor
                fi
                if ! isNumeric "$1"
                then
                    echo >&2 "error: value for '-wakecheck' must be numeric"
                    return 1
                fi
                wakecheck=$1
                if [[ ${wakecheck} -lt ${minWakeCheck} ]] || [[ ${wakecheck} -gt ${maxWakeCheck} ]]
                then
                    echo >&2 "error: value for '-wakecheck' must be between ${minWakeCheck} and ${maxWakeCheck}"
                    return 1
                fi
                ;;
            *)
                usage monitor
                ;;
        esac
        shift
    done

    if [[ ${fsettle} -eq 1 ]]
    then
        settle=${dfltSettle}
    fi
    if [[ ${finterval} -eq 1 ]]
    then
        interval=${dfltInterval}
    fi
    if [[ ${fwakecheck} -eq 1 ]]
    then
        wakecheck=${dfltWakeCheck}
    fi

    if ! checkFileRW "${datadir}/${tmpdir}/${pidfile}" Y
    then
        echo >&2 "error: unable to create '${datadir}/${tmpdir}/${pidfile}'"
        return 4
    fi

    if [[ ${infg} -eq 1 ]]
    then
        "${mypath}" _zzinternal "${datadir}/${logdir}/${logfile}" ${interval} ${settle} ${wakecheck} ${notify} ${forcepoll} ${agent} ${nwnoop} ${dw} ${debug} &
        echo "info: monitor is running($!)"
    else
        exec "${mypath}" _zzinternal "${datadir}/${logdir}/${logfile}" ${interval} ${settle} ${wakecheck} ${notify} ${forcepoll} ${agent} ${nwnoop} ${dw} ${debug}
    fi

    return 0
}

doUninstall()
{
    local url=""
    local plist=""
    local res=""
    local -i tret

    if [[ $# -ne 0 ]]
    then
        usage uninstall
    fi

    if ! isAgent
    then
        echo "info: agent is not configured"
        return 0
    fi

    plist=$(cat "${datadir}/${cfgdir}/${lanamef}")
    plist="${ladir}/${plist}.plist"

    res=$(doStatus 2>&1)
    tret=$?
    res=$(echo "${res}" | sed -e 's/^[a-z]*: //')
    if [[ ${tret} -ne 1 ]]
    then
        echo >&2 "error: ${res}"
        return 2
    fi

    rm -f "${plist}" >& /dev/null
    rm -f "${datadir}/${cfgdir}/${lanamef}" >& /dev/null

    return 0
}

doInstall()
{
    local -i settle=0
    local -i interval=0
    local -i wakecheck=0
    local nwnoop="-nonwnoop"
    local url=""
    local nf="-nonotify"
    local dw="-nodw"
    local plist=""
    local res=""
    local -i tret
    local -i fsettle=1
    local -i finterval=1
    local -i fwakecheck=1
    local -i fnotify=1
    local -i fdw=1

    res=$(doStatus 2>&1)
    tret=$?
    res=$(echo "${res}" | sed -e 's/^[a-z]*: //')
    if [[ ${tret} -ne 1 ]]
    then
        echo >&2 "error: ${res}"
        return 2
    fi

    while [[ $# -gt 0 ]]
    do
        case "$1" in
            "-nwnoop")
                nwnoop="-nwnoop"
                ;;
            "-notify")
                if [[ ${fnotify} -eq 0 ]]
                then
                    usage install
                fi
                nf="-notify"
                fnotify=0
                ;;
            "-nonotify")
                if [[ ${fnotify} -eq 0 ]]
                then
                    usage install
                fi
                nf="-nonotify"
                fnotify=0
                ;;
#            "-dw")
#                if [[ ${fdw} -eq 0 ]]
#                then
#                    usage install
#                fi
#                dw="-dw"
#                fdw=0
#                ;;
#            "-nodw")
#                if [[ ${fdw} -eq 0 ]]
#                then
#                    usage install
#                fi
#                dw="-nodw"
#                fdw=0
#                ;;
            "-settle")
                if [[ ${fsettle} -eq 0 ]]
                then
                    usage install
                fi
                fsettle=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage install
                fi
                if ! isNumeric "$1"
                then
                    echo >&2 "error: value for '-settle' must be numeric"
                    return 1
                fi
                settle=$1
                if [[ ${settle} -lt ${minSettle} ]] || [[ ${settle} -gt ${maxSettle} ]]
                then
                    echo >&2 "error: value for '-settle' must be between ${minSettle} and ${maxSettle}"
                    return 1
                fi
                ;;
            "-interval")
                if [[ ${finterval} -eq 0 ]]
                then
                    usage install
                fi
                finterval=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage install
                fi
                if ! isNumeric "$1"
                then
                    echo >&2 "error: value for '-interval' must be numeric"
                    return 1
                fi
                interval=$1
                if [[ ${interval} -lt ${minInterval} ]] || [[ ${interval} -gt ${maxInterval} ]]
                then
                    echo >&2 "error: value for '-interval' must be between ${minInterval} and ${maxInterval}"
                    return 1
                fi
                ;;
            "-wakecheck")
                if [[ ${fwakecheck} -eq 0 ]]
                then
                    usage install
                fi
                fwakecheck=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage install
                fi
                if ! isNumeric "$1"
                then
                    echo >&2 "error: value for '-wakecheck' must be numeric"
                    return 1
                fi
                wakecheck=$1
                if [[ ${wakecheck} -lt ${minWakeCheck} ]] || [[ ${wakecheck} -gt ${maxWakeCheck} ]]
                then
                    echo >&2 "error: value for '-wakecheck' must be between ${minWakeCheck} and ${maxWakeCheck}"
                    return 1
                fi
                ;;
            *)
                if [[ "${url}" != "" ]]
                then
                    usage install
                fi
                url="$1"
                ;;
        esac
        shift
    done

    if [[ "${url}" == "" ]]
    then
        url="${dfltAgentName}"
    fi
    plist="${ladir}/${url}.plist"

    if [[ ${fsettle} -eq 1 ]]
    then
        settle=${dfltSettle}
    fi
    if [[ ${finterval} -eq 1 ]]
    then
        interval=${dfltInterval}
    fi
    if [[ ${fwakecheck} -eq 1 ]]
    then
        wakecheck=${dfltWakeCheck}
    fi

    if ! checkFileRW "${datadir}/${cfgdir}/${lanamef}" Y
    then
        echo >&2 "error: unable to create '${datadir}/${cfgdir}/${lanamef}'"
        return 2
    fi
    echo "${url}" > "${datadir}/${cfgdir}/${lanamef}"

    if ! checkFileRW "${plist}" Y
    then
        rm -f "${datadir}/${cfgdir}/${lanamef}"
        echo >&2 "error: unable to create '${plist}'"
        return 3
    fi

    cat - > "${plist}" 2>/dev/null <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
        <key>Label</key>
        <string>${url}</string>
	<key>LimitLoadToSessionType</key>
	<string>Aqua</string>
        <key>ProgramArguments</key>
        <array>
        <string>${mypath}</string>
        <string>monitor</string>
        <string>-settle</string>
        <string>${settle}</string>
        <string>-interval</string>
        <string>${interval}</string>
        <string>-wakecheck</string>
        <string>${wakecheck}</string>
        <string>${nf}</string>
        <string>${nwnoop}</string>
        <string>-fg</string>
        <string>-agent</string>
        </array>
        <key>RunAtLoad</key>
        <true/>
        <key>KeepAlive</key>
        <true/>
        <key>AbandonProcessGroup</key>
        <true/>
</dict>
</plist>
EOF
    if [[ $? -ne 0 ]]
    then
        rm -f "${datadir}/${cfgdir}/${lanamef}"
        rm -f "${plist}"
        echo >&2 "error: unable to create '${plist}'"
        return 4
    fi

    return 0
}

doClear()
{
    local a
    local act
    local envt
    local elist
    local tmp
    local -i verbose=1
    local -i didsomething=1
    local -i tret

    if [[ $# -lt 2 ]] || [[ $# -gt 3 ]]
    then
        usage clear
    fi
    envt="$1"
    act="$2"
    if [[ $# -eq 3 ]]
    then
        if [[ "$3" == "-verbose" ]]
        then
            verbose=0
        else
            usage clear
        fi
    fi

    if [[ ${#act} != 1 ]]
    then
        usage clear
    fi
    if [[ ! "${actions}" =~ " ${act} "  ]]
    then
        usage clear
    fi
    if [[ "${act}" == "b" ]]
    then
        act="a i"
    fi

    if [[ "${envt}" == "${envAll}" ]]
    then
        if ! cd "${datadir}/${actdir}" >& /dev/null
        then
            echo >&2 "error: unable to access '${datadir}/${actdir}'"
            return 1
        fi
        elist=$(ls 2> /dev/null)
    else
        elist="${envt}"
    fi

    for envt in ${elist}
    do
        checkDir "${datadir}/${actdir}/${envt}"
        tret=$?
        if [[ ${tret} -gt 1 ]]
        then
            echo >&2 "error: unable to access '${datadir}/${actdir}/${envt}'"
            return 1
        elif [[ ${tret} -eq 0 ]]
        then
            for a in ${act}
            do
                checkDir "${datadir}/${actdir}/${envt}/${a}"
                tret=$?
                if [[ ${tret} -gt 1 ]]
                then
                    echo >&2 "error: unable to access '${datadir}/${actdir}/${envt}/${a}'"
                    return 1
                elif [[ ${tret} -eq 0 ]]
                then
                    if [[ ${verbose} -eq 0 ]]
                    then
                        echo "info: removing action '${envt}:${a}'"
                    fi
                    rm -rf "${datadir}/${actdir}/${envt}/${a}" >& /dev/null
                    didsomething=0
                elif [[ ${verbose} -eq 0 ]]
                then
                    echo "info: action '${envt}:${a}' not found"
                fi
            done
            tmp=$(ls "${datadir}/${actdir}/${envt}" 2>/dev/null)
            if [[ "${tmp}" == "" ]]
            then
                rm -rf "${datadir}/${actdir}/${envt}" >& /dev/null
                didsomething=0
            fi
        elif [[ ${verbose} -eq 0 ]]
        then
            echo "info: no actions found for environment '${envt}'"
        fi
    done

    if [[ ${didsomething} -eq 0 ]]
    then
        if ! checkFileRW "${datadir}/${tmpdir}/${reffile}" Y
        then
            echo >&2 "error: unable to mark refresh"
            return 2
        fi
    fi

    return 0
}

doSet()
{
    local a
    local act
    local envt
    local tenv
    local elist
    local cmd=""
    local cmdstr=""
    local tmp
    local -i notify=1
    local -i silent=1
    local -i didsomething=1
    local -i tret

    if [[ $# -lt 3 ]]
    then
        usage set
    fi
    envt="$1"
    act="$2"
    shift
    shift
    if [[ "$1" == "-notify" ]]
    then
        notify=0
        shift
    elif [[ "$1" == "-silent" ]]
    then
        silent=0
        shift
    fi

    if [[ $# -gt 0 ]]
    then
        cmd="$1"
        shift
        if [[ "${cmd:0:1}" != "/" ]]
        then
            echo >&2 "error: '${cmd}' is not an absolute path"
            return 1
        fi
        cmdstr="'${cmd}'"
        for tmp in "$@"
        do
            cmdstr="${cmdstr} '${tmp}'"
        done
    fi

    if [[ ${notify} -eq 0 ]]
    then
        if [[ "${cmd}" != "" ]]
        then
            usage set
        fi
    elif [[ ${silent} -eq 0 ]]
    then
        if [[ "${cmd}" == "" ]]
        then
            usage set
        fi
    elif [[ "${cmd}" == "" ]]
    then
        usage set
    fi

    if [[ ${#act} != 1 ]]
    then
        usage set
    fi
    if [[ ! "${actions}" =~ " ${act} "  ]]
    then
        usage set
    fi

    if  [[ "${act}" == "b" ]] || [[ "${act}" == "i" ]] 
    then
        if [[ "${envt}" == "${envWake}" ]]
        then
            echo >&2 "error: 'i' and 'b' actions not supported for '${envWake}'"
            return 1
        fi
    fi

    if [[ "${act}" == "b" ]]
    then
        act="a i"
    fi

    if [[ "${envt}" == "${envDefault}" ]]
    then
        elist="${envt}"
    elif [[ "${envt}" == "${envWake}" ]]
    then
        elist="${envt}"
    elif [[ "${envt}" == "${envBattery}" ]]
    then
        if [[ ${enablePower} -eq 0 ]]
        then
            elist="${envt}"
        else
            echo >&2 "error: '${envt}' is not a valid environment name"
            return 2
        fi
    elif [[ "${envt}" == "${envAll}" ]]
    then
        elist=$(cat "${datadir}/${cfgdir}/${envnames}")
        elist="${elist} ${envDefault} ${envBattery} ${envWake}"
    elif ! isValidEnvironment "${envt}"
    then
        echo >&2 "error: '${envt}' is not a valid environment name"
        return 2
    else
        elist="${envt}"
    fi

    if [[ "${cmd}" != "" ]]
    then
        if ! checkFileRX "${cmd}"
        then
            echo >&2 "error: '${cmd}' does not exist or is not executable"
            return 3
        fi
    fi

    for tenv in ${elist}
    do
        if ! checkDir "${datadir}/${actdir}/${tenv}" Y
        then
            echo >&2 "error: unable to access '${datadir}/${actdir}/${tenv}'"
            return 4
        fi

        for a in ${act}
        do
            if ! checkDir "${datadir}/${actdir}/${tenv}/${a}" Y
            then
                echo >&2 "error: unable to access '${datadir}/${actdir}/${tenv}/${a}'"
                return 5
            fi
            if [[ ${silent} -eq 0 ]]
            then
                if checkFileRW "${datadir}/${actdir}/${tenv}/${a}/${notifyfile}"
                then
                    if ! rm "${datadir}/${actdir}/${tenv}/${a}/${notifyfile}" >& /dev/null
                    then
                        echo >&2 "error: unable to delete '${datadir}/${actdir}/${tenv}/${a}/${notifyfile}'"
                        return 6
                    fi
                    didsomething=0
                fi
            else
                if ! checkFileRW "${datadir}/${actdir}/${tenv}/${a}/${notifyfile}" Y
                then
                    echo >&2 "error: unable to create '${datadir}/${actdir}/${tenv}/${a}/${notifyfile}'"
                    return 7
                fi
                didsomething=0
            fi
            if [[ "${cmd}" == "" ]]
            then
                if checkFileRW "${datadir}/${actdir}/${tenv}/${a}/${cmdfile}"
                then
                    if ! rm "${datadir}/${actdir}/${tenv}/${a}/${cmdfile}" >& /dev/null
                    then
                        echo >&2 "error: unable to delete '${datadir}/${actdir}/${tenv}/${a}/${cmdfile}'"
                        return 8
                    fi
                    didsomething=0
                fi
            else
                if ! checkFileRWX "${datadir}/${actdir}/${tenv}/${a}/${cmdfile}" Y
                then
                    echo >&2 "error: unable to create '${datadir}/${actdir}/${tenv}/${a}/${cmdfile}'"
                    return 9
                fi
                echo "${cmdstr}" > "${datadir}/${actdir}/${tenv}/${a}/${cmdfile}" 2>&1
                didsomething=0
            fi
        done
    done

    if [[ ${didsomething} -eq 0 ]]
    then
        if ! checkFileRW "${datadir}/${tmpdir}/${reffile}" Y
        then
            echo >&2 "error: unable to mark refresh as needed"
            return 10
        fi
    fi

    return 0
}

rotateLogs()
{
    local logname="$1"
    local -i i=9
    local -i n

    while [[ ${i} -ge ${maxlogs} ]]
    do
        rm -f "${logname}".${i} >& /dev/null
        i=${i}-1
    done
    
    i=${maxlogs}-1
    n=${i}-1
    while [[ ${n} -ge 1 ]]
    do
        if [[ -f "${logname}".${n} ]]
        then
            mv "${logname}"."${n}" "${logname}"."${i}" >& /dev/null
        fi
        i=${i}-1
        n=${n}-1
    done
    if [[ -f "${logname}" ]]
    then
        mv "${logname}" "${logname}".1 >& /dev/null
    fi

    touch "${logname}" >& /dev/null

    return 0
}

autoRotateLogs()
{
    local logdir
    local logfname
    local -i ret=0
    local -i tret=0
    local -i curday=0
    local -i cycleday=0
    local -i force=1

    if [[ $# -gt 0 ]]
    then
        force=0
    fi
    curday=$(date '+%s')
    curday=${curday}/${secsPerDay}

    if [[ ${force} -eq 1 ]]
    then
        if [[ ${logcycle} -le 0 ]] || [[ "${mylog}" == "" ]]
        then
            return 0
        fi
        cycleday=${lastlogcycle}+${logcycle}
        if [[ ${curday} -le ${cycleday} ]]
        then
            return 0
        fi
    fi

    logdir=$(dirname "${mylog}" 2>/dev/null)
    logfname=$(basename "${mylog}" 2>/dev/null)
    if [[ "${logdir}" == "" ]] || [[ "${logfname}" == "" ]]
    then
        logMsg "ERROR: invalid log configuration, unable to rotate log"
        ret=2
    elif ! cd "${logdir}" >& /dev/null
    then
        logMsg "ERROR: '${logdir}' is not accessible, unable to rotate log"
        ret=3
    else
        rotateLogs "${logfname}"
        ret=$?
        if [[ ${ret} -ne 0 ]]
        then
            logMsg "ERROR: problem rotating log"
            ret=4
        fi
    fi

    if [[ "${actlog}" != "" ]]
    then
        logdir=$(dirname "${actlog}" 2>/dev/null)
        logfname=$(basename "${actlog}" 2>/dev/null)
        if [[ "${logdir}" == "" ]] || [[ "${logfname}" == "" ]]
        then
            logMsg "ERROR: invalid action log configuration, unable to rotate log"
            ret=5
        elif ! cd "${logdir}" >& /dev/null
        then
            logMsg "ERROR: '${logdir}' is not accessible, unable to rotate action log"
            ret=6
        else
            rotateLogs "${logfname}"
            tret=$?
            if [[ ${tret} -ne 0 ]]
            then
                logMsg "ERROR: problem rotating action log"
                tret=7
            fi
            if [[ ${ret} -eq 0 ]]
            then
                ret=${tret}
            fi
        fi
    fi

    if [[ ${ret} -eq 0 ]]
    then
        checkFileR "${datadir}/${tmpdir}/${lastlogcyclefile}"
        ret=$?
        if [[ ${ret} -gt 1 ]]
        then
            logMsg "ERROR: unable to access '${datadir}/${tmpdir}/${lastlogcyclefile}'"
            ret=8
        else
            echo "${curday}" > "${datadir}/${tmpdir}/${lastlogcyclefile}" 2>/dev/null
            lastlogcycle=${curday}
            ret=1
        fi
    fi

    return ${ret}
}

doLog()
{
    local -i action=1
    local -i faction=1
    local -i follow=1
    local -i ffollow=1
    local -i clear=1
    local -i fno=0
    local -i fclear=1
    local -i ffno=1
    local -i info=1
    local -i finfo=1
    local -i rotate=1
    local -i frotate=1
    local -i itmp=0
    local llogdir
    local logfname
    local logpath
    local tmp
    local tmp2

    while [[ $# -gt 0 ]]
    do
        case "$1" in
            "-fno")
                if [[ ${ffno} -eq 0 ]] || \
                   [[ ${ffollow} -eq 0 ]] || \
                   [[ ${fclear} -eq 0 ]] || \
                   [[ ${finfo} -eq 0 ]] || \
                   [[ ${frotate} -eq 0 ]]
                then
                    usage log
                fi
                ffno=0
                shift
                if [[ $# -lt 1 ]]
                then
                    usage log
                fi
                if ! isnumeric "$1"
                then
                    usage log
                fi
                fno=$1
                if [[ ${fno} -lt 1 ]]
                then
                    usage log
                fi
                ;;
            "-action")
                if [[ ${faction} -eq 0 ]] || \
                   [[ ${finfo} -eq 0 ]] || \
                   [[ ${frotate} -eq 0 ]]
                then
                    usage log
                fi
                faction=0
                action=0
                ;;
            "-clear")
                if [[ ${fclear} -eq 0 ]] || \
                   [[ ${ffno} -eq 0 ]] || \
                   [[ ${finfo} -eq 0 ]] || \
                   [[ ${frotate} -eq 0 ]] || \
                   [[ ${ffollow} -eq 0 ]]
                then
                    usage log
                fi
                fclear=0
                clear=0
                ;;
            "-follow")
                if [[ ${fclear} -eq 0 ]] || \
                   [[ ${ffno} -eq 0 ]] || \
                   [[ ${finfo} -eq 0 ]] || \
                   [[ ${frotate} -eq 0 ]] || \
                   [[ ${ffollow} -eq 0 ]]
                then
                    usage log
                fi
                ffollow=0
                follow=0
                ;;
            "-info")
                if [[ ${fclear} -eq 0 ]] || \
                   [[ ${ffno} -eq 0 ]] || \
                   [[ ${finfo} -eq 0 ]] || \
                   [[ ${faction} -eq 0 ]] || \
                   [[ ${frotate} -eq 0 ]] || \
                   [[ ${ffollow} -eq 0 ]]
                then
                    usage log
                fi
                finfo=0
                info=0
                ;;
            "-rotate")
                if [[ ${fclear} -eq 0 ]] || \
                   [[ ${ffno} -eq 0 ]] || \
                   [[ ${finfo} -eq 0 ]] || \
                   [[ ${frotate} -eq 0 ]] || \
                   [[ ${faction} -eq 0 ]] || \
                   [[ ${ffollow} -eq 0 ]]
                then
                    usage log
                fi
                frotate=0
                rotate=0
                ;;
            *)
                usage log
                ;;
        esac
        shift
    done

    loadConfig Y
    if [[ $? -gt 1 ]]
    then
        return 1
    fi

    if [[ ${rotate} -eq 0 ]]
    then
        if ! tmp=$(doStatus 2>&1)
        then
            tmp=$(echo "${tmp}" | sed -e 's/^.*: //')
            echo >&2 "error: ${tmp}"
            return 1
        fi
        if ! checkFileRW "${datadir}/${tmpdir}/${forcelogcyclefile}" Y
        then
            echo >&2 "error: unable to access '${datadir}/${tmpdir}/${forcelogcyclefile}'"
            return 1
        fi
        return 0
    elif [[ ${info} -eq 0 ]]
    then
        echo "info: maximum log files  = ${maxlogs}"
        if [[ ${logcycle} -gt 0 ]]
        then
            echo "info: auto rotation days = ${logcycle}"
        else
            echo "info: auto rotation is not enabled"
        fi
        if [[ ${lastlogcycle} -gt 0 ]]
        then
            itmp=${lastlogcycle}*${secsPerDay}
            tmp=$(date -j -f '%s' ${itmp} '+%F')
            itmp=$(( ${logcycle}*${secsPerDay} + ${lastlogcycle}*${secsPerDay} ))
            tmp2=$(date -j -f '%s' ${itmp} '+%F')
            echo "info: last rotation on ${tmp}, next scheduled on ${tmp2}"
        fi
        echo
        
        logpath="${datadir}/${logdir}/${logfile}"
        llogdir=$(dirname "${logpath}")
        logfname=$(basename "${logpath}")
        if ! cd "${llogdir}" >& /dev/null
        then
            echo >&2 "error: '${llogdir}' is not accessible"
            return 1
        fi
        echo "info: log location is '${llogdir}'"
        tmp=$(ls "${logfname}"* 2>/dev/null)
        if [[ "${tmp}" == "" ]]
        then
            echo "info: no log files"
        else
            echo "info: log files..."
            ls -lrt "${logfname}"*
        fi

        if [[ "${actlog}" == "" ]]
        then
            echo
            echo "info: action log is not defined"
            return 0
        fi
        if ! checkFileRW "${actlog}" Y
        then
            echo >&2 "error: unable to access '${actlog}'"
            return 1
        fi
        logpath="${actlog}"
        llogdir=$(dirname "${logpath}")
        logfname=$(basename "${logpath}")
        if ! cd "${llogdir}" >& /dev/null
        then
            echo >&2 "error: '${llogdir}' is not accessible"
            return 1
        fi
        echo
        echo "info: action log location is '${llogdir}'"
        tmp=$(ls "${logfname}"* 2>/dev/null)
        if [[ "${tmp}" == "" ]]
        then
            echo "info: no log files"
        else
            echo "info: log files..."
            ls -lrt "${logfname}"*
        fi
    else
        if [[ ${action} -eq 0 ]]
        then
            if [[ "${actlog}" == "" ]]
            then
                echo >&2 "error: action log is not defined"
                return 1
            fi
            if ! checkFileRW "${actlog}" Y
            then
                echo >&2 "error: unable to access '${actlog}'"
                return 1
            fi
            logpath="${actlog}"
        else
            logpath="${datadir}/${logdir}/${logfile}"
        fi

        llogdir=$(dirname "${logpath}")
        logfname=$(basename "${logpath}")
        if [[ ${fno} -ne 0 ]]
        then
            logfname="${logfname}.${fno}"
        fi
        logpath="${llogdir}/${logfname}"
    
        if [[ ${clear} -eq 0 ]]
        then
            if ! checkDir "${llogdir}" Y
            then
                echo >&2 "error: '${logpath}' is not accessible"
                return 1
            else
                cd "${llogdir}" >& /dev/null
                rm -f "${logfname}" "${logfname}".[123456789] >& /dev/null
                touch "${logfname}" >& /dev/null
            fi
        else
            if ! checkFileR "${logpath}"
            then
                echo >&2 "error: log file '${logpath}' not found"
                return 1
            fi
            if [[ ${follow} -eq 0 ]]
            then
                tail -f "${logpath}"
            else
                cat "${logpath}"
            fi
        fi
    fi

    return 0
}

doInit()
{
    local res
    local -i tret=0

    if [[ $# -ne 0 ]]
    then
        usage init
    fi

    res=$(doStatus 2>&1)
    tret=$?
    res=$(echo "${res}" | sed -e 's/^[a-z]*: //')
    if [[ ${tret} -ne 1 ]]
    then
        echo >&2 "error: ${res}"
        return 2
    fi

    doUninstall >& /dev/null

    if cd "${datadir}/${cfgdir}" 
    then
        rm -rf ./* >& /dev/null
    fi
    if cd "${datadir}/${actdir}"
    then
        rm -rf ./* >& /dev/null
    fi
    if cd "${datadir}/${tmpdir}"
    then
        rm -rf ./* >& /dev/null
    fi
    if cd "${datadir}/${logdir}"
    then
        rm -rf ./* >& /dev/null
    fi

    init

    return 0
}

listConfig()
{
    local tmp
    local -i script=$1

    if [[ ${script} -eq 0 ]]
    then
        echo "'${me}' config -clear"
    fi

    if [[ ! -e "${datadir}/${cfgdir}/${warntimeout}" ]]
    then
        tmp=" (default)"
    else
        tmp=""
    fi
    if [[ ${script} -eq 0 ]]
    then
        if [[ "${tmp}" == "" ]]
        then
            echo "'${me}' config -warntimeout ${cmdwarntimeout}"
        fi
    else
        echo "warning timeout       : ${cmdwarntimeout}${tmp}"
    fi

    if [[ ! -e "${datadir}/${cfgdir}/${killtimeout}" ]]
    then
        tmp=" (default)"
    else
        tmp=""
    fi
    if [[ ${script} -eq 0 ]]
    then
        if [[ "${tmp}" == "" ]]
        then
            echo "'${me}' config -killtimeout ${cmdkilltimeout}"
        fi
    else
        echo "kill timeout          : ${cmdkilltimeout}${tmp}"
    fi

    if [[ ! -e "${datadir}/${cfgdir}/${acsqfile}" ]]
    then
        tmp=" (default)"
    else
        tmp=""
    fi
    if [[ ${script} -eq 0 ]]
    then
        if [[ "${tmp}" == "" ]]
        then
            echo "'${me}' config -acsq ${acSQ}"
        fi
    else
        echo "AC sleep quantum      : ${acSQ}${tmp}"
    fi

    if [[ ${enablePower} -eq 0 ]]
    then
        if [[ ! -e "${datadir}/${cfgdir}/${btsqfile}" ]]
        then
            tmp=" (default)"
        else
            tmp=""
        fi
        if [[ ${script} -eq 0 ]]
        then
            if [[ "${tmp}" == "" ]]
            then
                echo "'${me}' config -btsq ${btSQ}"
            fi
        else
            echo "battery sleep quantum : ${btSQ}${tmp}"
        fi
    fi

    if [[ ! -e "${datadir}/${cfgdir}/${numlogfile}" ]]
    then
        tmp=" (default)"
    else
        tmp=""
    fi
    if [[ ${script} -eq 0 ]]
    then
        if [[ "${tmp}" == "" ]]
        then
            echo "'${me}' config -maxlogs ${maxlogs}"
        fi
    else
        echo "maximum log files     : ${maxlogs}${tmp}"
    fi

    if [[ ! -e "${datadir}/${cfgdir}/${logcyclefile}" ]]
    then
        tmp=" (default)"
    else
        tmp=""
    fi
    if [[ ${script} -eq 0 ]]
    then
        if [[ "${tmp}" == "" ]]
        then
            echo "'${me}' config -logrotate ${logcycle}"
        fi
    else
        echo "log rotate            : ${logcycle}${tmp}"
    fi

    if [[ ${script} -eq 0 ]]
    then
        if [[ "${actlog}" != "" ]]
        then
            echo "'${me}' config -actionlog '${actlog}'"
        fi
    elif [[ "${actlog}" == "" ]]
    then
        echo "action log            : <not defined>"
    elif checkFileRW "${actlog}" Y
    then
        echo "action log            : ${actlog}"
    else
        echo "action log            : INACCESSIBLE (${actlog})"
    fi

    return 0
}

clearConfig()
{
    local -i ret=0
    local -i tret=0
    local -i didsometing=1

    checkFileRW "${datadir}/${cfgdir}/${warntimeout}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${cfgdir}/${warntimeout}'"
        ret=${ret}+1
    elif [[ ${tret} -eq 0 ]]
    then
        rm -f "${datadir}/${cfgdir}/${warntimeout}" >& /dev/null
        didsomething=0
    fi

    checkFileRW "${datadir}/${cfgdir}/${killtimeout}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${cfgdir}/${killtimeout}'"
        ret=${ret}+1
    elif [[ ${tret} -eq 0 ]]
    then
        rm -f "${datadir}/${cfgdir}/${killtimeout}" >& /dev/null
        didsomething=0
    fi

    checkFileRW "${datadir}/${cfgdir}/${acsqfile}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${cfgdir}/${acsqfile}'"
        ret=${ret}+1
    elif [[ ${tret} -eq 0 ]]
    then
        rm -f "${datadir}/${cfgdir}/${acsqfile}" >& /dev/null
        didsomething=0
    fi

    checkFileRW "${datadir}/${cfgdir}/${btsqfile}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${cfgdir}/${btsqfile}'"
        ret=${ret}+1
    elif [[ ${tret} -eq 0 ]]
    then
        rm -f "${datadir}/${cfgdir}/${btsqfile}" >& /dev/null
        didsomething=0
    fi

    checkFileRW "${datadir}/${cfgdir}/${numlogfile}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${cfgdir}/${numlogfile}'"
        ret=${ret}+1
    elif [[ ${tret} -eq 0 ]]
    then
        rm -f "${datadir}/${cfgdir}/${numlogfile}" >& /dev/null
        didsomething=0
    fi

    checkFileRW "${datadir}/${cfgdir}/${logcyclefile}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${cfgdir}/${logcyclefile}'"
        ret=${ret}+1
    elif [[ ${tret} -eq 0 ]]
    then
        rm -f "${datadir}/${cfgdir}/${logcyclefile}" >& /dev/null
        didsomething=0
    fi

    checkFileRW "${datadir}/${tmpdir}/${lastlogcyclefile}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${tmpdir}/${lastlogcyclefile}'"
        ret=${ret}+1
    elif [[ ${tret} -eq 0 ]]
    then
        rm -f "${datadir}/${tmpdir}/${lastlogcyclefile}" >& /dev/null
        didsomething=0
    fi

    checkFileRW "${datadir}/${cfgdir}/${actionlog}"
    tret=$?
    if [[ ${tret} -gt 1 ]]
    then
        echo >&2 "error: unable to remove '${datadir}/${cfgdir}/${actionlog}'"
        ret=${ret}+1
    elif [[ ${tret} -eq 0 ]]
    then
        rm -f "${datadir}/${cfgdir}/${actionlog}" >& /dev/null
        didsomething=0
    fi

    echo ${didsomething}
    return ${ret}
}

doConfig()
{
    local tmp
    local -i fclear=1
    local -i fscript=1
    local -i facsq=1
    local -i acsq=0
    local -i fbtsq=1
    local -i btsq=0
    local -i fwarn=1
    local -i warn=0
    local -i fkill=1
    local -i kill=0
    local -i fnlogs=1
    local -i nlogs=0
    local -i flcycle=1
    local -i lcycle=0
    local -i fxpath=1
    local xpath
    local -i didsomething=1
    local -i itmp=0
    local -i ret=0

    loadConfig Y
    ret=$?
    if [[ ${ret} -gt 1 ]]
    then
        return 1
    fi

    if [[ $# -eq 0 ]]
    then
        listConfig 1
        return 0
    fi

    while [[ $# -gt 0 ]]
    do
        case "$1" in
            "-clear")
                if [[ ${fwarn} -eq 0 ]] || [[ ${fkill} -eq 0 ]] || \
                   [[ ${facsq} -eq 0 ]] || [[ ${fbtsq} -eq 0 ]] || \
                   [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || \
                   [[ ${fxpath} -eq 0 ]] ||[[ ${fnlogs} -eq 0 ]]
                then
                    usage config
                fi
                fclear=0
                ;;
            "-script")
                if [[ ${fwarn} -eq 0 ]] || [[ ${fkill} -eq 0 ]] || \
                   [[ ${facsq} -eq 0 ]] || [[ ${fbtsq} -eq 0 ]] || \
                   [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || \
                   [[ ${fxpath} -eq 0 ]] ||[[ ${fnlogs} -eq 0 ]]
                then
                    usage config
                fi
                fscript=0
                ;;
            "-actionlog")
                if [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || [[ ${fxpath} -eq 0 ]]
                then
                    usage config
                fi
                fxpath=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage config
                fi
                xpath="$1"
                ;;
            "-acsq")
                if [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || [[ ${facsq} -eq 0 ]]
                then
                    usage config
                fi
                facsq=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage config
                fi
                if [[ "$1" == "-" ]]
                then
                    acsq=-1
                else
                    if ! isNumeric "$1"
                    then
                        echo >&2 "error: sleep quantum values must be numeric"
                        return 1
                    fi
                    acsq=$1
                    if [[ ${acsq} -lt ${minSleepQuantum} ]] || [[ ${acsq} -gt ${maxSleepQuantum} ]]
                    then
                        echo >&2 "error: sleep quantum values must be between ${minSleepQuantum} and ${maxSleepQuantum}"
                        return 2
                    fi
                fi
                ;;
            "-btsq")
                if [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || [[ ${fbtsq} -eq 0 ]]
                then
                    usage config
                fi
                if [[ ${enablePower} -ne 0 ]]
                then
                    echo >&2 "error: this system does not support a battery power source"
                    return 2
                fi
                fbtsq=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage config
                fi
                if [[ "$1" == "-" ]]
                then
                    btsq=-1
                else
                    if ! isNumeric "$1"
                    then
                        echo >&2 "error: sleep quantum values must be numeric"
                        return 1
                    fi
                    btsq=$1
                    if [[ ${btsq} -lt ${minSleepQuantum} ]] || [[ ${btsq} -gt ${maxSleepQuantum} ]]
                    then
                        echo >&2 "error: sleep quantum values must be between ${minSleepQuantum} and ${maxSleepQuantum}"
                        return 2
                    fi
                fi
                ;;
            "-warntimeout")
                if [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || [[ ${fwarn} -eq 0 ]]
                then
                    usage config
                fi
                fwarn=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage config
                fi
                if [[ "$1" == "-" ]]
                then
                    warn=-1
                else
                    if ! isNumeric "$1"
                    then
                        echo >&2 "error: timeout values must be numeric"
                        return 1
                    fi
                    warn=$1
                    if [[ ${warn} -lt ${minTimeout} ]] || [[ ${warn} -gt ${maxTimeout} ]]
                    then
                        echo >&2 "error: timeout values must be between ${minTimeout} and ${maxTimeout}"
                        return 2
                    fi
                fi
                ;;
            "-killtimeout")
                if [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || [[ ${fkill} -eq 0 ]]
                then
                    usage config
                fi
                fkill=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage config
                fi
                if [[ "$1" == "-" ]]
                then
                    kill=-1
                else
                    if ! isNumeric "$1"
                    then
                        echo >&2 "error: timeout values must be numeric"
                        return 1
                    fi
                    kill=$1
                    if [[ ${kill} -lt ${minTimeout} ]] || [[ ${kill} -gt ${maxTimeout} ]]
                    then
                        echo >&2 "error: timeout values must be between ${minTimeout} and ${maxTimeout}"
                        return 2
                    fi
                fi
                ;;
            "-maxlogs")
                if [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || [[ ${fnlogs} -eq 0 ]]
                then
                    usage config
                fi
                fnlogs=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage config
                fi
                if [[ "$1" == "-" ]]
                then
                    nlogs=-1
                else
                    if ! isNumeric "$1"
                    then
                        echo >&2 "error: maxlogs value must be numeric"
                        return 1
                    fi
                    nlogs=$1
                    if [[ ${nlogs} -lt ${minNumLogs} ]] || [[ ${nlogs} -gt ${maxNumLogs} ]]
                    then
                        echo >&2 "error: maxlogs value must be between ${minNumLogs} and ${maxNumLogs}"
                        return 2
                    fi
                fi
                ;;
            "-logrotate")
                if [[ ${fscript} -eq 0 ]] || [[ ${fclear} -eq 0 ]] || [[ ${flcycle} -eq 0 ]]
                then
                    usage config
                fi
                flcycle=0
                shift
                if [[ $# -eq 0 ]]
                then
                    usage config
                fi
                if [[ "$1" == "-" ]]
                then
                    lcycle=-1
                else
                    if ! isNumeric "$1"
                    then
                        echo >&2 "error: maxlogs value must be numeric"
                        return 1
                    fi
                    lcycle=$1
                    if [[ ${lcycle} -lt ${minLogCycle} ]] || [[ ${lcycle} -gt ${maxLogCycle} ]]
                    then
                        echo >&2 "error: logcycle value must be between ${minLogCycle} and ${maxLogCycle}"
                        return 2
                    fi
                fi
                ;;
            *)
                usage config
                ;;
        esac
        shift
    done

    if [[ ${fclear} -eq 0 ]]
    then
        if tmp=$(clearConfig 2>&1)
        then
            didsomething=${tmp}
        else
            echo >&2 "${tmp}"
            ret=1
        fi
    elif [[ ${fscript} -eq 0 ]]
    then
        listConfig 0
        return 0
    else
        if [[ ${fwarn} -eq 1 ]]
        then
            warn=${cmdwarntimeout}
        fi
        if [[ ${fkill} -eq 1 ]]
        then
            kill=${cmdkilltimeout}
        fi
        if [[ ${kill} -gt 0 ]] && [[ ${warn} -ge ${kill} ]]
        then
            echo >&2 "error: the warning timeout must be < the kill timeout"
            return 3
        fi

        if [[ ${fxpath} -eq 0 ]]
        then
            if [[ "${xpath}" == "-" ]]
            then
                checkFileRW "${datadir}/${cfgdir}/${actionlog}"
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to access '${datadir}/${cfgdir}/${actionlog}'"
                    return 4
                elif [[ ${ret} -eq 0 ]]
                then
                    rm -f "${datadir}/${cfgdir}/${actionlog}" >& /dev/null
                fi
            else
                if [[ "${xpath:0:1}" != "/" ]]
                then
                    echo >&2 "error: '${xpath}' is not an absolute path"
                    return 4
                fi
                checkFileRW "${xpath}" Y
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to create '${xpath}'"
                    return 4
                fi
                checkFileRW "${datadir}/${cfgdir}/${actionlog}" Y
                ret=$?
                if [[ ${ret} -ne 0 ]]
                then
                    echo >&2 "error: unable to write to '${datadir}/${cfgdir}/${actionlog}'"
                    return 4
                else
                    echo "${xpath}" > "${datadir}/${cfgdir}/${actionlog}" 2> /dev/null
                fi
            fi
            didsomething=0
        fi
    
        if [[ ${fwarn} -eq 0 ]]
        then
            if [[ ${warn} -lt 0 ]]
            then
                checkFileRW "${datadir}/${cfgdir}/${warntimeout}"
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to access '${datadir}/${cfgdir}/${warntimeout}'"
                    return 4
                elif [[ ${ret} -eq 0 ]]
                then
                    rm -f "${datadir}/${cfgdir}/${warntimeout}" >& /dev/null
                fi
            else
                if ! checkFileRW "${datadir}/${cfgdir}/${warntimeout}" Y
                then
                    echo >&2 "error: unable to write to '${datadir}/${cfgdir}/${warntimeout}'"
                    return 5
                fi
                echo "${warn}" > "${datadir}/${cfgdir}/${warntimeout}" 2>/dev/null
            fi
            didsomething=0
        fi
    
        if [[ ${fkill} -eq 0 ]]
        then
            if [[ ${kill} -lt 0 ]]
            then
                checkFileRW "${datadir}/${cfgdir}/${killtimeout}"
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to access '${datadir}/${cfgdir}/${killtimeout}'"
                    return 4
                elif [[ ${ret} -eq 0 ]]
                then
                    rm -f "${datadir}/${cfgdir}/${killtimeout}" >& /dev/null
                fi
            else
                if ! checkFileRW "${datadir}/${cfgdir}/${killtimeout}" Y
                then
                    echo >&2 "error: unable to write to '${datadir}/${cfgdir}/${killtimeout}'"
                    return 5
                fi
                echo "${kill}" > "${datadir}/${cfgdir}/${killtimeout}" 2>/dev/null
            fi
            didsomething=0
        fi
    
        if [[ ${facsq} -eq 0 ]]
        then
            if [[ ${acsq} -lt 0 ]]
            then
                checkFileRW "${datadir}/${cfgdir}/${acsqfile}"
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to access '${datadir}/${cfgdir}/${acsqfile}'"
                    return 4
                elif [[ ${ret} -eq 0 ]]
                then
                    rm -f "${datadir}/${cfgdir}/${acsqfile}" >& /dev/null
                fi
            else
                if ! checkFileRW "${datadir}/${cfgdir}/${acsqfile}" Y
                then
                    echo >&2 "error: unable to write to '${datadir}/${cfgdir}/${acsqfile}'"
                    return 5
                fi
                echo "${acsq}" > "${datadir}/${cfgdir}/${acsqfile}" 2>/dev/null
            fi
            didsomething=0
        fi
    
        if [[ ${fbtsq} -eq 0 ]]
        then
            if [[ ${btsq} -lt 0 ]]
            then
                checkFileRW "${datadir}/${cfgdir}/${btsqfile}"
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to access '${datadir}/${cfgdir}/${btsqfile}'"
                    return 4
                elif [[ ${ret} -eq 0 ]]
                then
                    rm -f "${datadir}/${cfgdir}/${btsqfile}" >& /dev/null
                fi
            else
                if ! checkFileRW "${datadir}/${cfgdir}/${btsqfile}" Y
                then
                    echo >&2 "error: unable to write to '${datadir}/${cfgdir}/${btsqfile}'"
                    return 5
                fi
                echo "${btsq}" > "${datadir}/${cfgdir}/${btsqfile}" 2>/dev/null
            fi
            didsomething=0
        fi
    
        if [[ ${fnlogs} -eq 0 ]]
        then
            if [[ ${nlogs} -lt 0 ]]
            then
                checkFileRW "${datadir}/${cfgdir}/${numlogfile}"
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to access '${datadir}/${cfgdir}/${numlogfile}'"
                    return 4
                elif [[ ${ret} -eq 0 ]]
                then
                    rm -f "${datadir}/${cfgdir}/${numlogfile}" >& /dev/null
                fi
            else
                if ! checkFileRW "${datadir}/${cfgdir}/${numlogfile}" Y
                then
                    echo >&2 "error: unable to write to '${datadir}/${cfgdir}/${numlogfile}'"
                    return 5
                fi
                echo "${nlogs}" > "${datadir}/${cfgdir}/${numlogfile}" 2>/dev/null
            fi
            didsomething=0
        fi

        if [[ ${flcycle} -eq 0 ]]
        then
            if [[ ${lcycle} -lt 0 ]]
            then
                checkFileRW "${datadir}/${cfgdir}/${logcyclefile}"
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to remove '${datadir}/${cfgdir}/${logcyclefile}'"
                    return 4
                elif [[ ${ret} -eq 0 ]]
                then
                    rm -f "${datadir}/${cfgdir}/${logcyclefile}" >& /dev/null
                fi
                checkFileRW "${datadir}/${tmpdir}/${lastlogcyclefile}"
                ret=$?
                if [[ ${ret} -gt 1 ]]
                then
                    echo >&2 "error: unable to remove '${datadir}/${tmpdir}/${lastlogcyclefile}'"
                    return 4
                elif [[ ${ret} -eq 0 ]]
                then
                    rm -f "${datadir}/${tmpdir}/${lastlogcyclefile}" >& /dev/null
                fi
            else
                if ! checkFileRW "${datadir}/${cfgdir}/${logcyclefile}" Y
                then
                    echo >&2 "error: unable to write to '${datadir}/${cfgdir}/${logcyclefile}'"
                    return 5
                fi
                echo "${lcycle}" > "${datadir}/${cfgdir}/${logcyclefile}" 2>/dev/null
            fi
            didsomething=0
        fi

    fi

    if [[ ${didsomething} -eq 0 ]]
    then
        if ! checkFileRW "${datadir}/${tmpdir}/${reffile}" Y
        then
            echo >&2 "error: unable to mark refresh"
            return 5
        fi
    fi

    return ${ret}
}

cleanupInternal()
{
    local -i verbose=1
    local p

    if [[ $# -gt 0 ]] && [[ "$1" == "0" ]]
    then
        verbose=0
    fi

    for p in $(pgrep -f -u "${myuid}" "${netwatcher}")
    do
        if [[ ${verbose} -eq 0 ]]
        then
            echo "info: killing netwatcher(${p})"
        fi
        kill -TERM "${p}"
    done
    rm -f "${datadir}/${tmpdir}/${nwpidfile}" >& /dev/null
    rm -f "${datadir}/${tmpdir}/${sleepfile}" >& /dev/null
    rm -f "${datadir}/${tmpdir}/${wakefile}" >& /dev/null

    for p in $(pgrep -f -u "${myuid}" "${sleepwatcher} --pidfile ${datadir}/${tmpdir}/${swpidfile} --wakeup")
    do
        if [[ ${verbose} -eq 0 ]]
        then
            echo "info: killing sleepwatcher(${p})"
        fi
        kill -TERM "${p}"
    done
    rm -f "${datadir}/${tmpdir}/${swpidfile}" >& /dev/null
    rm -f "${datadir}/${tmpdir}/${nwchangefile}" >& /dev/null

    return 0
}

doCleanup()
{
    local -i ret
    local -i verbose=1
    local msg

    if [[ $# -gt 1 ]]
    then
        usage cleanup
    elif [[ $# -gt 0 ]]
    then
        if [[ "$1" == "-verbose" ]]
        then
            verbose=0
        else
            usage cleanup
        fi
    fi

    msg=$(doStatus 2>&1)
    ret=$?
    if [[ ${ret} -eq 0 ]] || \
       [[ ${ret} -eq 4 ]] || \
       [[ ${ret} -eq 5 ]] 
    then
        msg=$(echo "${msg}" | sed -e 's/^[a-z]*: //')
        echo >&2 "error: ${msg}"
        return 1
    fi

    cleanupInternal ${verbose}

    return 0
}

doPause()
{
    local tmp=""
    local -i pausetime=0
    local -i norescan=1

    if [[ $# -gt 2 ]]
    then
        usage pause
    elif [[ $# -eq 2 ]]
    then
        if [[ "$2" == "-norescan" ]]
        then
            norescan=0
        else
            usage pause
        fi
        tmp="$1"
    elif [[ $# -eq 1 ]]
    then
        if [[ "$1" == "-norescan" ]]
        then
            norescan=0
        else
            tmp="$1"
        fi
    else
        tmp=""
    fi

    if [[ "${tmp}" != "" ]]
    then
        if [[ "${tmp}" == "-signed" ]] || [[ "${tmp}" == "-s" ]] || \
           [[ "${tmp}" == "-float" ]] || [[ "${tmp}" == "-f" ]] 
        then
            usage pause
        fi
        if ! pausetime=$(validPauseInterval "${tmp}")
        then
            usage pause
        fi
    fi
    if ! tmp=$(doStatus 2>&1)
    then
        tmp=$(echo "${tmp}" | sed -e 's/^.*: //')
        echo >&2 "error: ${tmp}"
        return 1
    fi
    if echo "${tmp}" | grep -q 'paused'
    then
        tmp=$(echo "${tmp}" | sed -e 's/^.*: //' -e 's/ .*$//')
        echo "info: ${tmp} is already paused"
    else
        if ! checkFileRW "${datadir}/${tmpdir}/${pausefile}" Y
        then
            echo >&2 "error: unable to access '${datadir}/${tmpdir}/${pausefile}'"
            return 1
        fi
        echo "${pausetime}" > "${datadir}/${tmpdir}/${pausefile}" 2>/dev/null
        if [[ ${norescan} -eq 0 ]]
        then
            if ! checkFileRW "${datadir}/${tmpdir}/${norescanfile}" Y
            then
                echo >&2 "error: unable to create '${datadir}/${tmpdir}/${norescanfile}'"
                return 2
            fi
        fi
    fi

    return 0
}

doResume()
{
    local tmp
    local pid
    local -i norescan=-1
    local -i tret

    if [[ $# -gt 1 ]]
    then
        usage resume
    elif [[ $# -eq 1 ]]
    then
        if [[ "$1" == "-norescan" ]]
        then
            norescan=0
        elif [[ "$1" == "-rescan" ]]
        then
            norescan=1
        else
            usage resume
        fi
    fi

    if ! tmp=$(doStatus 2>&1)
    then
        tmp=$(echo "${tmp}" | sed -e 's/^.*: //')
        echo >&2 "error: ${tmp}"
        return 1
    fi
    if ! echo "${tmp}" | grep -q 'paused'
    then
        tmp=$(echo "${tmp}" | sed -e 's/^.*: //' -e 's/ .*$//')
        echo "info: ${tmp} is not paused"
        return 0
    fi

#   Do we override rescan?

    if [[ ${norescan} -ge 0 ]]
    then
        if [[ ${norescan} -eq 0 ]]
        then
            if ! checkFileRW "${datadir}/${tmpdir}/${norescanfile}" Y
            then
                echo >&2 "error: unable to create '${datadir}/${tmpdir}/${norescanfile}'"
                return 1
            fi
        else
            rm -f "${datadir}/${tmpdir}/${norescanfile}" >& /dev/null
        fi
    fi

    checkFileRW "${datadir}/${tmpdir}/${pausefile}"
    if [[ $? -gt 1 ]]
    then
        echo >&2 "error: unable to access '${datadir}/${tmpdir}/${pausefile}'"
        return 1
    fi
    rm -f "${datadir}/${tmpdir}/${pausefile}" >&/dev/null

    return 0
}

doSleep()
{
    if ! checkFileRW "${datadir}/${tmpdir}/${sleepfile}" Y
    then
        return 1
    fi
    date '+%s' >"${datadir}/${tmpdir}/${sleepfile}" 2>/dev/null
    return 0
}

doWake()
{
    if ! checkFileRW "${datadir}/${tmpdir}/${wakefile}" Y
    then
        return 1
    fi
    date '+%s' >"${datadir}/${tmpdir}/${wakefile}" 2>/dev/null
    return 0
}

doAcPower()
{
    if ! checkFileRW "${datadir}/${tmpdir}/${acpowerfile}" Y
    then
        return 1
    fi
    date '+%s' >"${datadir}/${tmpdir}/${acpowerfile}" 2>/dev/null
    return 0
}

doBattery()
{
    if ! checkFileRW "${datadir}/${tmpdir}/${batteryfile}" Y
    then
        return 1
    fi
    date '+%s' >"${datadir}/${tmpdir}/${batteryfile}" 2>/dev/null
    return 0
}

doVersion()
{
    if [[ $# -ne 0 ]]
    then
        usage version
    fi
    echo "Version ${version}"
    echo "${copyright}"
    return 0
}

trap "cleanup 120" INT HUP TERM
me=$(basename "$0")
myuid=$(id -u)
mypath=$(canonPath "$0")
checkHasBattery

if [[ $# -lt 1 ]]
then
    usage
fi
cmd="$1"
shift
if [[ "${cmd}" == "help" ]]
then
    doHelp "$@"
    exit $?
fi

umask 022
init

case "${cmd}" in
    "version")
        doVersion "$@"
        ret=$?
        ;;
    "list")
        doList "$@"
        ret=$?
        ;;
    "set")
        doSet "$@"
        ret=$?
        ;;
    "clear")
        doClear "$@"
        ret=$?
        ;;
    "status")
        doStatus "$@"
        ret=$?
        ;;
    "start")
        doStart "$@"
        ret=$?
        ;;
    "stop")
        doStop "$@"
        ret=$?
        ;;
    "log")
        doLog "$@"
        ret=$?
        ;;
    "refresh")
        doRefresh "$@"
        ret=$?
        ;;
    "rescan")
        doRescan "$@"
        ret=$?
        ;;
    "monitor")
        doMonitor "$@"
        ret=$?
        ;;
    "install")
        doInstall "$@"
        ret=$?
        ;;
    "uninstall")
        doUninstall "$@"
        ret=$?
        ;;
    "init")
        doInit "$@"
        ret=$?
        ;;
    "config")
        doConfig "$@"
        ret=$?
        ;;
    "cleanup")
        doCleanup "$@"
        ret=$?
        ;;
    "pause")
        doPause "$@"
        ret=$?
        ;;
    "resume")
        doResume "$@"
        ret=$?
        ;;
    "_zzinternal")
        doInternal "$@"
        ret=$?
        ;;
    "_zzsleep")
        doSleep "$@"
        ret=$?
        ;;
    "_zzwake")
        doWake "$@"
        ret=$?
        ;;
    "_zzacpower")
        doAcPower "$@"
        ret=$?
        ;;
    "_zzbattery")
        doBattery "$@"
        ret=$?
        ;;
    *)
        usage
        ;;
esac

cleanup ${ret}
